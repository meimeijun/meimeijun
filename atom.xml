<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>山中小屋</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dword.top/"/>
  <updated>2018-11-01T08:38:49.842Z</updated>
  <id>https://dword.top/</id>
  
  <author>
    <name>meimeijun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git远程库</title>
    <link href="https://dword.top/git%E6%9C%AC%E5%9C%B0%E8%BF%9C%E7%A8%8B%E5%BA%93.html"/>
    <id>https://dword.top/git本地远程库.html</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-11-01T08:38:49.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h3><p>在本地创建一个空文件<br>进入文件夹  </p><p><font color="green" size="2">git init</font><br></p><h3 id="添加文件到缓存区"><a href="#添加文件到缓存区" class="headerlink" title="添加文件到缓存区"></a>添加文件到缓存区</h3><p>在对应目录下  </p><p><font color="green" size="2">git add 文件</font><br></p><p><font color="green" size="2">git add . 目录</font><br><br><a id="more"></a></p><h3 id="执行到仓库"><a href="#执行到仓库" class="headerlink" title="执行到仓库"></a>执行到仓库</h3><p><font color="green" size="2">git commit -m ‘注释说明’</font><br></p><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><h5 id="未add的情况下"><a href="#未add的情况下" class="headerlink" title="未add的情况下"></a>未add的情况下</h5><ul><li>git status查看当前状态</li><li><ul><li>查看修改的具体内容</li></ul></li><li><ul><li><ul><li><font color="green" size="2">git diff</font><br></li></ul></li></ul></li><li><ul><li><ul><li><font color="green" size="2">git diff HEAD [HEAD^] — <file>比较文件不同</file></font><br></li></ul></li></ul></li></ul><h5 id="提交的情况下-想回退版本"><a href="#提交的情况下-想回退版本" class="headerlink" title="提交的情况下(想回退版本)"></a>提交的情况下(想回退版本)</h5><ul><li><font color="green" size="2">git reset —hard HEAD^</font><br><br><font color="red" size="2">&lt;^表示上一个~1表示上一个&gt;</font><br></li></ul><h5 id="如果想回到刚才的那个版本，后悔了"><a href="#如果想回到刚才的那个版本，后悔了" class="headerlink" title="如果想回到刚才的那个版本，后悔了"></a>如果想回到刚才的那个版本，后悔了</h5><ul><li>查看之前的记录找到版本号commit  </li><li><ul><li><font color="green" size="2">git reset —hard 1094a(写前几位就可以了)</font><br></li></ul></li><li>如果关闭了窗口，看不到以前的输出</li><li><ul><li><font color="green" size="2">git reflog(查看到以前提交的)</font><br></li></ul></li></ul><h3 id="撤回修改"><a href="#撤回修改" class="headerlink" title="撤回修改"></a>撤回修改</h3><h5 id="工作区修改，想进行修改撤回"><a href="#工作区修改，想进行修改撤回" class="headerlink" title="工作区修改，想进行修改撤回"></a>工作区修改，想进行修改撤回</h5><ul><li><font color="green" size="2">git checkout — 文件 </font><br><br><font color="red" size="2">(撤回工作区，或者暂存区上一次的样子) </font><br></li></ul><h5 id="添加到暂存区，想撤回到工作区"><a href="#添加到暂存区，想撤回到工作区" class="headerlink" title="添加到暂存区，想撤回到工作区"></a>添加到暂存区，想撤回到工作区</h5><ul><li><font color="green" size="2">git reset HEAD <file> </file></font><br><br><font color="red" size="2">&lt;当我们用HEAD时，表示最新的版本&gt; <file> </file></font><br></li></ul><h3 id="删除工作区文件"><a href="#删除工作区文件" class="headerlink" title="删除工作区文件"></a>删除工作区文件</h3><h5 id="确认删除"><a href="#确认删除" class="headerlink" title="确认删除"></a>确认删除</h5><p><font color="green" size="2">git rm <file> </file></font><br></p><p><font color="green" size="2">再提交git commit -m ‘’ <file> </file></font><br></p><h5 id="误删除"><a href="#误删除" class="headerlink" title="误删除"></a>误删除</h5><p><font color="green" size="2">git checkout — 文件 </font><br></p><p><font color="red" size="2">(撤回工作区，或者暂存区上一次的样子)</font><br></p><h3 id="连接远程库"><a href="#连接远程库" class="headerlink" title="连接远程库"></a>连接远程库</h3><ul><li>ssh-keygen -t rsa -C “邮箱”</li><li>登陆GitHub，打开“Account settings”，“SSH Keys”页面，点“Add SSH Key“填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容</li><li><p><font color="green" size="2">关联本地库 git remote add origin <a href="https://github.com/meimeijun/english.git" target="_blank" rel="noopener">https://github.com/meimeijun/english.git</a> </font><br><br><font color="red" size="2">&lt;由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。&gt;</font><br></p></li><li><p>从现在起，只要本地作了提交，就可以通过命令：<br>git push origin 分支名称</p></li></ul><h3 id="从远程克隆到本地"><a href="#从远程克隆到本地" class="headerlink" title="从远程克隆到本地"></a>从远程克隆到本地</h3><ul><li><font color="green" size="2">git clone git@github.com:meimeijun/gitskills.git </font><br></li></ul><h3 id="查看远程库"><a href="#查看远程库" class="headerlink" title="查看远程库"></a>查看远程库</h3><ul><li><font color="green" size="2">git remote </font><br></li><li><font color="green" size="2">git remote -v(详细信息) </font><br></li></ul><h3 id="推送同一个远程分支冲突的时候"><a href="#推送同一个远程分支冲突的时候" class="headerlink" title="推送同一个远程分支冲突的时候"></a>推送同一个远程分支冲突的时候</h3><p><font color="red" size="2">(创建本地和远程分支的名称最好一致git checkout -b 分支名称origin/分支名称) </font><br></p><ol><li>把最新的分支抓下来 git pull</li><li>也失败，是否没有设置之间的连接用 git branch —set-upstream-to=origin/&lt;分支名称&gt; 分支名称</li><li>再git pull</li><li>在本地解决冲突以后</li><li>再推送 git push origin dev</li></ol><h3 id="把本地未push的分叉提交历史整理成直线"><a href="#把本地未push的分叉提交历史整理成直线" class="headerlink" title="把本地未push的分叉提交历史整理成直线"></a>把本地未push的分叉提交历史整理成直线</h3><p>git rebase</p><h3 id="忽略提交"><a href="#忽略提交" class="headerlink" title="忽略提交"></a>忽略提交</h3><ol><li>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去  </li><li>.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<br><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a>  </li><li><p>文件里示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">Windows</span>:</span><br><span class="line"><span class="selector-tag">Thumbs</span><span class="selector-class">.db</span></span><br><span class="line"><span class="selector-tag">ehthumbs</span><span class="selector-class">.db</span></span><br><span class="line"><span class="selector-tag">Desktop</span><span class="selector-class">.ini</span></span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">Python</span>:</span><br><span class="line">*<span class="selector-class">.py</span><span class="selector-attr">[cod]</span></span><br><span class="line">*<span class="selector-class">.so</span></span><br><span class="line">*<span class="selector-class">.egg</span></span><br><span class="line">*<span class="selector-class">.egg-info</span></span><br><span class="line"><span class="selector-tag">dist</span></span><br><span class="line"><span class="selector-tag">build</span></span><br><span class="line"></span><br><span class="line"># <span class="selector-tag">My</span> <span class="selector-tag">configurations</span>:</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.ini</span></span><br><span class="line"><span class="selector-tag">deploy_key_rsa</span></span><br></pre></td></tr></table></figure></li><li><p>最后一步就是把.gitignore也提交到Git</p></li></ol><h3 id="对于规则里面想强制提交的不想忽略的"><a href="#对于规则里面想强制提交的不想忽略的" class="headerlink" title="对于规则里面想强制提交的不想忽略的"></a>对于规则里面想强制提交的不想忽略的</h3><ol><li>git add -f App.class</li><li>或者查看某个规则</li><li>git check-ignore -v App.class</li></ol><h3 id="修改繁琐的命令"><a href="#修改繁琐的命令" class="headerlink" title="修改繁琐的命令"></a>修改繁琐的命令</h3><p><font color="red" size="2">(加上—global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用) </font><br></p><ul><li>git config —global alias.st status</li><li>git config —global alias.co checkout</li><li>git config —global alias.ci commit</li><li>git config —global alias.br branch</li><li>git config —global alias.unstage ‘reset HEAD’</li><li>git config —global alias.last ‘log -1’</li></ul><p><font color="red" size="2">(Git配置文件都放在.git/config中的[alias]后面) </font><br></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;初始化本地仓库&quot;&gt;&lt;a href=&quot;#初始化本地仓库&quot; class=&quot;headerlink&quot; title=&quot;初始化本地仓库&quot;&gt;&lt;/a&gt;初始化本地仓库&lt;/h3&gt;&lt;p&gt;在本地创建一个空文件&lt;br&gt;进入文件夹  &lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;2&quot;&gt;git init&lt;/font&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加文件到缓存区&quot;&gt;&lt;a href=&quot;#添加文件到缓存区&quot; class=&quot;headerlink&quot; title=&quot;添加文件到缓存区&quot;&gt;&lt;/a&gt;添加文件到缓存区&lt;/h3&gt;&lt;p&gt;在对应目录下  &lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;2&quot;&gt;git add 文件&lt;/font&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;2&quot;&gt;git add . 目录&lt;/font&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="https://dword.top/categories/git/"/>
    
    
      <category term="git" scheme="https://dword.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git分支</title>
    <link href="https://dword.top/git%E5%88%86%E6%94%AF.html"/>
    <id>https://dword.top/git分支.html</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-11-01T08:38:20.198Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分支原理"><a href="#分支原理" class="headerlink" title="分支原理"></a>分支原理</h3><p><font color="green" size="2">参照：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000</a></font><br></p><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>(创建的分支会在原有分支的进度上往前走一个位置，原分支指针不变)</p><ul><li><font color="green" size="2">git branch 分支名称</font><br></li></ul><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><ul><li><font color="green" size="2">git checkout 分支名称</font><br></li><li><font color="green" size="2">(或者 git checkout -b 分支名称)</font><br><br><font color="red" size="2"><git checkout命令加上-b参数表示创建并切换=""></git></font><br><a id="more"></a><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4></li><li><font color="green" size="2">git branch</font><br></li><li><font color="red" size="2">前面的*代表当前是使用的分支</font><br></li></ul><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><ul><li><font color="green" size="2">git merge dev</font><br></li></ul><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><ul><li><font color="green" size="2">git branch -d dev</font><br></li></ul><h4 id="保存现场-保存当前进行到一半的工作"><a href="#保存现场-保存当前进行到一半的工作" class="headerlink" title="保存现场(保存当前进行到一半的工作)"></a>保存现场(保存当前进行到一半的工作)</h4><ul><li><font color="green" size="2">git stash</font><br></li></ul><h5 id="查看保存的现场"><a href="#查看保存的现场" class="headerlink" title="查看保存的现场"></a>查看保存的现场</h5><ul><li><font color="green" size="2">git stash list</font><br></li></ul><h5 id="回复现场"><a href="#回复现场" class="headerlink" title="回复现场"></a>回复现场</h5><ul><li><font color="blue" size="2">git stash apply stash@{0}(指定现场) 但不删除stash中内容</font><br></li><li><font color="red" size="2">删除需要 git stash drop</font><br></li><li><font color="blue" size="2">git stash pop 回复的同时也删除</font><br></li></ul><h4 id="丢弃一个没有被合并过的分支"><a href="#丢弃一个没有被合并过的分支" class="headerlink" title="丢弃一个没有被合并过的分支"></a>丢弃一个没有被合并过的分支</h4><ul><li><font color="green" size="2">git branch -D <name>强行删除</name></font><br></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分支原理&quot;&gt;&lt;a href=&quot;#分支原理&quot; class=&quot;headerlink&quot; title=&quot;分支原理&quot;&gt;&lt;/a&gt;分支原理&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;2&quot;&gt;参照：&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000&lt;/a&gt;&lt;/font&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;创建分支&quot;&gt;&lt;a href=&quot;#创建分支&quot; class=&quot;headerlink&quot; title=&quot;创建分支&quot;&gt;&lt;/a&gt;创建分支&lt;/h4&gt;&lt;p&gt;(创建的分支会在原有分支的进度上往前走一个位置，原分支指针不变)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;green&quot; size=&quot;2&quot;&gt;git branch 分支名称&lt;/font&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;切换分支&quot;&gt;&lt;a href=&quot;#切换分支&quot; class=&quot;headerlink&quot; title=&quot;切换分支&quot;&gt;&lt;/a&gt;切换分支&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;green&quot; size=&quot;2&quot;&gt;git checkout 分支名称&lt;/font&gt;&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;green&quot; size=&quot;2&quot;&gt;(或者 git checkout -b 分支名称)&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;red&quot; size=&quot;2&quot;&gt;&lt;git checkout命令加上-b参数表示创建并切换=&quot;&quot;&gt;&lt;/git&gt;&lt;/font&gt;&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="https://dword.top/categories/git/"/>
    
    
      <category term="git" scheme="https://dword.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git标签</title>
    <link href="https://dword.top/git%E6%A0%87%E7%AD%BE.html"/>
    <id>https://dword.top/git标签.html</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-11-01T08:34:05.014Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ol><li><font color="green" size="2">切换到要打标签的分支上</font><br></li><li><font color="green" size="2">git tag v1.0(默认标签是打在最新提交的commit上的)</font><br></li><li><font color="green" size="2">切换到具体的commit上git tag v0.9 commit_id</font><br></li></ol><h4 id="创建带有说明的标签"><a href="#创建带有说明的标签" class="headerlink" title="创建带有说明的标签"></a>创建带有说明的标签</h4><p><font color="green" size="2">git tag -a  标签名称 -m “说明” commit_id</font><br></p><p><font color="red" size="2">(-a指定标签名，-m指定说明文字)</font><br></p><h4 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h4><ul><li>git tag(标签列表)</li><li>git show 标签名称(具体某个标签的信息)</li></ul><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><p><font color="red" size="2">(因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除) </font><br></p><p><font color="green" size="2">———git tag -d 标签名称</font><br></p><h4 id="推送某个标签到远程"><a href="#推送某个标签到远程" class="headerlink" title="推送某个标签到远程"></a>推送某个标签到远程</h4><p><font color="green" size="2">git push origin 标签名称</font><br></p><h4 id="推送全部尚未推送到远程的本地标签"><a href="#推送全部尚未推送到远程的本地标签" class="headerlink" title="推送全部尚未推送到远程的本地标签"></a>推送全部尚未推送到远程的本地标签</h4><p><font color="green" size="2"> git push origin —tags </font><br></p><h4 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h4><ol><li>先从本地删除 <font color="green" size="2"> git tag -d 标签名称 </font><br></li><li>远程删除 <font color="green" size="2">git push origin :refs/tags/标签名称 </font><br></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;创建标签&quot;&gt;&lt;a href=&quot;#创建标签&quot; class=&quot;headerlink&quot; title=&quot;创建标签&quot;&gt;&lt;/a&gt;创建标签&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;font color=&quot;green&quot; size=&quot;2&quot;&gt;切换到要打标签的分支上&lt;/font&gt;&lt;br&gt;&lt;/li&gt;
      
    
    </summary>
    
      <category term="git" scheme="https://dword.top/categories/git/"/>
    
    
      <category term="git" scheme="https://dword.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>浅谈字典查询速度快的原因</title>
    <link href="https://dword.top/%E5%93%88%E5%B8%8C%E8%A1%A8.html"/>
    <id>https://dword.top/哈希表.html</id>
    <published>2018-09-01T16:00:00.000Z</published>
    <updated>2018-11-01T08:40:56.177Z</updated>
    
    <content type="html"><![CDATA[<p>在查找大数据方面，map要优于数组，对于数组说来就是依次下标遍历了，直到找到这个数据为止，map理想情况下只需要0(1)的时间级，其查找的时间复杂度与元素的数量多少无关。那么map到底用了什么办法达到了这么快的查找速度。</p><h4 id="map的组成"><a href="#map的组成" class="headerlink" title="map的组成"></a>map的组成</h4><p>简单来说，map的组成是有一个哈希表（也叫散列表）,是根据关键码值（key value)而直接进行访问的数据结构，也就是通过关键码值映射到表中一个位置来访问记录，以加快查找的速度。映射这种关系的函数就是哈希函数（散列函数）。 </p><h4 id="关系大概如下"><a href="#关系大概如下" class="headerlink" title="关系大概如下"></a>关系大概如下</h4><p>记录存储的位置 = 哈希函数(key)  </p><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数到底是怎么映射这种关系的呢，哈希算法有很多种，用哪种算法，没有完美的算法，简单来说，使用一套算法，将所有的健转化为一个数组的索引，值为其对应的值，这样就可以通过f(key)找到数组的下标一次查找到对应的值，达到快速查找的目的。<br><br>举个最简单的例子，当然这里没有任何算法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#比如一个一组key是[3,5,4,7]，在数组中的形式如下</span></span><br><span class="line">    <span class="number">0</span>           </span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>           值</span><br><span class="line">    <span class="number">4</span>           值</span><br><span class="line">    <span class="number">5</span>           值</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">    <span class="number">7</span>           值</span><br></pre></td></tr></table></figure></p><p>这样做虽然在一定程度上浪费了空间，但是在这个大内存时代，用合理的空间换取时间是能承受的，而这种通过f(key)查找值的方法，也决定了key-value在形式上无序的，跟插入的顺序无关，跟key在哈希表中的f(key)顺序有关。<br></p><p>当然肯定会引申出几个问题，比如数值超过可以能计算的范围，怎么哈希计算，又比如理想的情况下哈希值是均匀分布，但是不一定所有被哈希的值一定是不一样，可能得到相同的哈希值对应多个值，这种情况也叫哈希冲突，这种冲突肯定是不能避免的，遇到哈希冲突又该怎么样，这个数组的长度又应该如何确定，如果长度太小，空间很容易满造成冲突，太长又浪费空间等等，下面将对此做简单的介绍。<br><br><a id="more"></a></p><h4 id="常用的哈希算法"><a href="#常用的哈希算法" class="headerlink" title="常用的哈希算法"></a>常用的哈希算法</h4><p>实际工作中徐视不同的情况采用不同的哈希函数，通常考虑的的因素有：  </p><ul><li>计算哈希函数所需时间</li><li>关键字的长度</li><li>哈希表的大小</li><li>关键字的分布情况</li><li>记录的查找频率</li></ul><h5 id="1-直接寻址法"><a href="#1-直接寻址法" class="headerlink" title="1.直接寻址法"></a>1.直接寻址法</h5><p>取关键字或者关键字的某个线性函数值作为哈希地址，即H(key)=key 或者 H(key) = a*key +b(a,b为整数)，如果H(key)的哈希地址上已经有值了，那么就往下一个位置找，直到找到没有值的位置就把元素放进去，最简单的就是我上面举的那个例子。</p><h5 id="2-数字分析法"><a href="#2-数字分析法" class="headerlink" title="2.数字分析法"></a>2.数字分析法</h5><p>分析一组数据，比如一组出生年月，发现前几位数字一般都相同，月日差别很大，所以取后面的几位数字来构建哈希地址</p><h5 id="3-平方取中法"><a href="#3-平方取中法" class="headerlink" title="3.平方取中法"></a>3.平方取中法</h5><p>对关键字进行平方运算，然后取结果的中间几位作为哈希地址。假如有以下关键字序列{421，423，436}，平方之后的结果为{177241，178929，190096}，那么可以取{72，89，00}作为Hash地址</p><h5 id="4-折叠法"><a href="#4-折叠法" class="headerlink" title="4.折叠法"></a>4.折叠法</h5><p>折叠法即将关键字分割成位数相同的几部分,最后一部分位数可以不同,然后取这几部分的叠加和(注意:叠加和时去除进位)作为哈希地址，数位叠加可以有移位叠加和间界叠加两种方法.移位叠加是将分割后的每一部分的最低位对齐,然后相加;间界叠加是从一端向另一端沿分割界来回折叠,然后对齐相加.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">比如<span class="number">548623247</span> </span><br><span class="line">数位叠加                间接叠加</span><br><span class="line">    <span class="number">548</span>                      <span class="number">548</span></span><br><span class="line">    <span class="number">623</span>                      <span class="number">326</span></span><br><span class="line">+   <span class="number">247</span>             +        <span class="number">247</span></span><br><span class="line">——————————             ——————————————</span><br><span class="line">   <span class="number">1418</span>                     <span class="number">1121</span></span><br><span class="line">H(key) = <span class="number">418</span>         H(key) = <span class="number">121</span></span><br></pre></td></tr></table></figure></p><h5 id="5-随机数法"><a href="#5-随机数法" class="headerlink" title="5. 随机数法"></a>5. 随机数法</h5><p>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即H(key)=random(key),其中random为随机函数。通常用于关键字长度不等时采用此法</p><h5 id="6-除留余数法"><a href="#6-除留余数法" class="headerlink" title="6.除留余数法"></a>6.除留余数法</h5><p>找一个不大于哈希表表长m除最大的质数或m取余数作为哈希地址</p><h4 id="处理哈希冲突的方法"><a href="#处理哈希冲突的方法" class="headerlink" title="处理哈希冲突的方法"></a>处理哈希冲突的方法</h4><h5 id="1-开放定址法"><a href="#1-开放定址法" class="headerlink" title="1.开放定址法"></a>1.开放定址法</h5><p>Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)</p><p>其中m为表长，di为增量序列</p><p>如果di值可能为1,2,3,…m-1，称线性探测再散列。</p><p>如果di取值可能为1,-1,2,-2,4,-4,9,-9,16,-16,…k<em>k,-k</em>k(k&lt;=m/2)</p><p>称二次探测再散列。</p><p>如果di取值可能为伪随机数列。称伪随机探测再散列。</p><p>比如有一组关键字{12，13，25，23，38，34，6，84，91}，Hash表长为11，Hash函数为address(key)=key%11，当插入12(hash(12)=1)，13(hash(13)=2)，25(hash(25)=3)时可以直接插入，而当插入23时，地址1被占用了，因此沿着地址1依次往下探测(探测步长可以根据情况而定,如(hash(23)+1)%11=2,(hash(23)+2)%11=3,(hash(23)+3)%11=4)，直到探测到地址4，发现为空，则将23插入其中。</p><h5 id="2-链地址法（拉链法"><a href="#2-链地址法（拉链法" class="headerlink" title="2.链地址法（拉链法)"></a>2.链地址法（拉链法)</h5><p>当存储结构是链表时，多采用拉链法。其基本思路是：将所有具有相同哈希地址的而不同关键字的数据元素连接到同一个单链表中。如果选定的哈希表长度为m，则可将哈希表定义为一个有m个头指针组成的指针数组T[0..m-1]，凡是哈希地址为i的数据元素，均以节点的形式插入到T[i]为头指针的单链表中。并且新的元素插入到链表的前端，这不仅因为方便，还因为经常发生这样的事实：新近插入的元素最优可能不久又被访问。</p><h5 id="3-哈希表的装填因子"><a href="#3-哈希表的装填因子" class="headerlink" title="3.哈希表的装填因子"></a>3.哈希表的装填因子</h5><p>装填因子是什么，它表示关键字填充哈希表后饱和的程度。装填因子越大冲突越大</p><h5 id="4-建立一个公共溢出区"><a href="#4-建立一个公共溢出区" class="headerlink" title="4.建立一个公共溢出区"></a>4.建立一个公共溢出区</h5><p>把凡是重复的放到一个缓存区中，当我通过f(key)查找时，发现找的不对，就在缓存区里找</p><h4 id="哈希表大小的确定"><a href="#哈希表大小的确定" class="headerlink" title="哈希表大小的确定"></a>哈希表大小的确定</h4><p>哈希表的尺寸最好是一个质数，当然根据实际情况，会有不同的大小，或者比如是10key值，大于10的数是2的4次方，一般设装填因子为0.7.如果大于设定的装填因子值就需要扩容，重新在开辟一片新的空间</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在查找大数据方面，map要优于数组，对于数组说来就是依次下标遍历了，直到找到这个数据为止，map理想情况下只需要0(1)的时间级，其查找的时间复杂度与元素的数量多少无关。那么map到底用了什么办法达到了这么快的查找速度。&lt;/p&gt;
&lt;h4 id=&quot;map的组成&quot;&gt;&lt;a href=&quot;#map的组成&quot; class=&quot;headerlink&quot; title=&quot;map的组成&quot;&gt;&lt;/a&gt;map的组成&lt;/h4&gt;&lt;p&gt;简单来说，map的组成是有一个哈希表（也叫散列表）,是根据关键码值（key value)而直接进行访问的数据结构，也就是通过关键码值映射到表中一个位置来访问记录，以加快查找的速度。映射这种关系的函数就是哈希函数（散列函数）。 &lt;/p&gt;
&lt;h4 id=&quot;关系大概如下&quot;&gt;&lt;a href=&quot;#关系大概如下&quot; class=&quot;headerlink&quot; title=&quot;关系大概如下&quot;&gt;&lt;/a&gt;关系大概如下&lt;/h4&gt;&lt;p&gt;记录存储的位置 = 哈希函数(key)  &lt;/p&gt;
&lt;h4 id=&quot;哈希函数&quot;&gt;&lt;a href=&quot;#哈希函数&quot; class=&quot;headerlink&quot; title=&quot;哈希函数&quot;&gt;&lt;/a&gt;哈希函数&lt;/h4&gt;&lt;p&gt;哈希函数到底是怎么映射这种关系的呢，哈希算法有很多种，用哪种算法，没有完美的算法，简单来说，使用一套算法，将所有的健转化为一个数组的索引，值为其对应的值，这样就可以通过f(key)找到数组的下标一次查找到对应的值，达到快速查找的目的。&lt;br&gt;&lt;br&gt;举个最简单的例子，当然这里没有任何算法&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#比如一个一组key是[3,5,4,7]，在数组中的形式如下&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;           &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;           值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;           值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;           值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;           值&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样做虽然在一定程度上浪费了空间，但是在这个大内存时代，用合理的空间换取时间是能承受的，而这种通过f(key)查找值的方法，也决定了key-value在形式上无序的，跟插入的顺序无关，跟key在哈希表中的f(key)顺序有关。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;当然肯定会引申出几个问题，比如数值超过可以能计算的范围，怎么哈希计算，又比如理想的情况下哈希值是均匀分布，但是不一定所有被哈希的值一定是不一样，可能得到相同的哈希值对应多个值，这种情况也叫哈希冲突，这种冲突肯定是不能避免的，遇到哈希冲突又该怎么样，这个数组的长度又应该如何确定，如果长度太小，空间很容易满造成冲突，太长又浪费空间等等，下面将对此做简单的介绍。&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="随记" scheme="https://dword.top/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="哈希表" scheme="https://dword.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>注意力训练的方法《思维导图大全集》</title>
    <link href="https://dword.top/%E6%B3%A8%E6%84%8F%E5%8A%9B.html"/>
    <id>https://dword.top/注意力.html</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2018-07-30T08:50:48.409Z</updated>
    
    <content type="html"><![CDATA[<h4 id="训练1"><a href="#训练1" class="headerlink" title="训练1:"></a>训练1:</h4><p>把收音机的音量逐渐关小到刚能听清楚时认真地听，听3分钟后回忆所听到的内容。</p><h4 id="训练2"><a href="#训练2" class="headerlink" title="训练2:"></a>训练2:</h4><p>在桌上摆三四件小物品，如瓶子、铅笔、书本、水杯等，对每件物品进行追踪思考各两<br>分钟，即在两分钟内思考与某件物品的一系列有关内容，比如思考瓶子时，想到各种各样的瓶子，想到各种瓶子的用途，想到瓶子的制造，造玻璃的矿石来源等。</p><p>这时，控制自己不想别的物品，两分钟后，立即把注意力转移到第二件物品上开始时，较难做到两分钟后的迅速转移，但如果每天练习10多分钟，两周后情况就大有好转了。</p><h4 id="训练3"><a href="#训练3" class="headerlink" title="训练3:"></a>训练3:</h4><p>盯住一张画，然后闭上眼睛，回忆画面内容，尽量做到完整，例如画中的人物、衣着、桌椅及各种摆设。回忆后睁开眼睛再看一下原画，如不完整，再重新回忆一遍。这个训练既可培养注意力集中的能力，也可提高更广范围的想象能力。</p><p>或者，在地图上寻找一个不太熟悉的城镇，在图上找出各个标记数字与其对应的建筑物，也能提高观察时集中注意力的能力。</p><a id="more"></a><h4 id="训练4"><a href="#训练4" class="headerlink" title="训练4:"></a>训练4:</h4><p>准备一张白纸，用7分钟时间，写完1〜300这一系列数字。测验前先练习一下，感到书写流利、很有把握后再开始，注意掌握时间，越接近结束速度会越慢，稍微放慢就会写不完。一般写到199时每个数不到1秒钟，后面的数字书写每个要超过1秒钟，另外换行书写也需花时间。</p><p>测验要求：能看清所写的字，不至于过分潦草，写错了不许改，也不许做标记，接着写下去；到规定时间，如写不完必须停笔。</p><p>结果评定：第一次差错出现在100以前为注意力较差；出现在101~180间为注意力一般；出现在181〜240间是注意力较好的；超过240出差错或完全对是注意力优秀。总的差错在7个以上为较差,错4〜7个为一般,错2〜3个为较好;只错一个为优秀。如果差错在100以前就出现了，但总的差错只有一两次，这种注意力仍是属于较好的。要是到180后才出错，但错得较多，说明这个人易于集中注意力，但很难维持下去。在规定时间内写不完则说明反应速度慢。</p><p>将测验情况记录，留与以后的测验作比较。</p><h4 id="训练5"><a href="#训练5" class="headerlink" title="训练5:"></a>训练5:</h4><p>假设你在读一本书、看一本杂志或一张报纸，你对它并不感兴趣，突然发现自己想到了大约10年前在墨西哥看的一场斗牛，你是怎样想到那里去的呢？看一下那本书你或许会发现你所读的最后一句话写的是遇难船发出了失事信号，集中分析一下思路，你可能会回忆出下面的过程：</p><p>遇难船使你想起了英法大战中的船只，有的人得救了，其他的人沉没了。你想到了死去的4位著名牧师，他们把自己的救生圈留给了水手。有一枚邮票纪念他们，由此你想到了其他的一些复印邮票硬币和5分镍币上的野牛，野牛又使你想到了公牛以及墨西哥的斗牛。这种集中注意力的练习实际上随时随地都可以进行。</p><p>经常在噪音或其他干扰环境中学习的人，要特别注意稳定情绪，不必一遇到不顺心的干扰就大动肝火。情绪不像动作，一旦激发起来便不易平静，结果对注意力的危害比出现的干扰现象更大。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;训练1&quot;&gt;&lt;a href=&quot;#训练1&quot; class=&quot;headerlink&quot; title=&quot;训练1:&quot;&gt;&lt;/a&gt;训练1:&lt;/h4&gt;&lt;p&gt;把收音机的音量逐渐关小到刚能听清楚时认真地听，听3分钟后回忆所听到的内容。&lt;/p&gt;
&lt;h4 id=&quot;训练2&quot;&gt;&lt;a href=&quot;#训练2&quot; class=&quot;headerlink&quot; title=&quot;训练2:&quot;&gt;&lt;/a&gt;训练2:&lt;/h4&gt;&lt;p&gt;在桌上摆三四件小物品，如瓶子、铅笔、书本、水杯等，对每件物品进行追踪思考各两&lt;br&gt;分钟，即在两分钟内思考与某件物品的一系列有关内容，比如思考瓶子时，想到各种各样的瓶子，想到各种瓶子的用途，想到瓶子的制造，造玻璃的矿石来源等。&lt;/p&gt;
&lt;p&gt;这时，控制自己不想别的物品，两分钟后，立即把注意力转移到第二件物品上开始时，较难做到两分钟后的迅速转移，但如果每天练习10多分钟，两周后情况就大有好转了。&lt;/p&gt;
&lt;h4 id=&quot;训练3&quot;&gt;&lt;a href=&quot;#训练3&quot; class=&quot;headerlink&quot; title=&quot;训练3:&quot;&gt;&lt;/a&gt;训练3:&lt;/h4&gt;&lt;p&gt;盯住一张画，然后闭上眼睛，回忆画面内容，尽量做到完整，例如画中的人物、衣着、桌椅及各种摆设。回忆后睁开眼睛再看一下原画，如不完整，再重新回忆一遍。这个训练既可培养注意力集中的能力，也可提高更广范围的想象能力。&lt;/p&gt;
&lt;p&gt;或者，在地图上寻找一个不太熟悉的城镇，在图上找出各个标记数字与其对应的建筑物，也能提高观察时集中注意力的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://dword.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="注意力" scheme="https://dword.top/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>观察力训练的方法《思维导图大全集》</title>
    <link href="https://dword.top/%E8%A7%82%E5%AF%9F%E5%8A%9B.html"/>
    <id>https://dword.top/观察力.html</id>
    <published>2018-06-27T16:00:00.000Z</published>
    <updated>2018-07-30T08:50:44.086Z</updated>
    
    <content type="html"><![CDATA[<h4 id="训练1："><a href="#训练1：" class="headerlink" title="训练1："></a>训练1：</h4><p>选一种静止物，比如一幢楼房、一个池塘或一棵树，对它进行观察。按照观察步骤，对观察物的形、声、色、味进行说明或描述。这种观察可以进行多次，直到自己能抓住主要观察物的特征为止。</p><h4 id="训练2"><a href="#训练2" class="headerlink" title="训练2:"></a>训练2:</h4><p>选一个目标，像电话、收音机、简单机械等，仔细把它看几分钟，然后等上大约一个钟</p><p>头，不看原物画一张图。把你的图与原物进行比较，注意画错了的地方，最后不看原物再画一张图，把画错了的地方更正过来。</p><h4 id="训练3"><a href="#训练3" class="headerlink" title="训练3:"></a>训练3:</h4><p>画一张中国地图，标出你所在的那个省的省界，和所在的省会，标完之后，把你标的与地图进行比较，注意有哪些地方搞错了，不过地图在眼前时不要去修正，把错处及如何修正都记在脑子里，然后丢幵地图再画一张。错误越多就越需要重复做这个练习。</p><p>在你有把握画出整个中国之后就画整个亚洲，然后画南美洲、欧洲以及其他的洲。要画得多详细由你自己决定。<br><a id="more"></a></p><h4 id="训练4"><a href="#训练4" class="headerlink" title="训练4:"></a>训练4:</h4><p>以运动的机器、变化的云或物理、化学实验为观察对象，按照观察步骤进行观察。这种观察特别强调知识的准备，要能说明运动变化着的形、声、色、味的特点及其变化原因。</p><h4 id="训练5"><a href="#训练5" class="headerlink" title="训练5:"></a>训练5:</h4><p>随便在书里或杂志里找一幅图，看它几分钟，尽可能多观察一些细节，然后凭记忆把它画出来^如果有人帮助，你可以不必画图，只要回答你朋友提出的有关图片细节的问题就可以了。问题可能会是这样的：有多少人？他们是什么样子？穿什么衣服？衣服是什么颜色？有多少房子？图片里有钟吗？几点了？等等。</p><h4 id="训练6"><a href="#训练6" class="headerlink" title="训练6:"></a>训练6:</h4><p>把练习扩展到一间房子。开始是你熟悉的房间，然后是你只看过几次的房间，最后是你只看过一次的房间，不过每次都要描述细节。不要满足于知道在西北角有一个书架，还要回忆一下书架有多少层，每层估计有多少书，是哪种书，等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;训练1：&quot;&gt;&lt;a href=&quot;#训练1：&quot; class=&quot;headerlink&quot; title=&quot;训练1：&quot;&gt;&lt;/a&gt;训练1：&lt;/h4&gt;&lt;p&gt;选一种静止物，比如一幢楼房、一个池塘或一棵树，对它进行观察。按照观察步骤，对观察物的形、声、色、味进行说明或描述。这种观察可以进行多次，直到自己能抓住主要观察物的特征为止。&lt;/p&gt;
&lt;h4 id=&quot;训练2&quot;&gt;&lt;a href=&quot;#训练2&quot; class=&quot;headerlink&quot; title=&quot;训练2:&quot;&gt;&lt;/a&gt;训练2:&lt;/h4&gt;&lt;p&gt;选一个目标，像电话、收音机、简单机械等，仔细把它看几分钟，然后等上大约一个钟&lt;/p&gt;
&lt;p&gt;头，不看原物画一张图。把你的图与原物进行比较，注意画错了的地方，最后不看原物再画一张图，把画错了的地方更正过来。&lt;/p&gt;
&lt;h4 id=&quot;训练3&quot;&gt;&lt;a href=&quot;#训练3&quot; class=&quot;headerlink&quot; title=&quot;训练3:&quot;&gt;&lt;/a&gt;训练3:&lt;/h4&gt;&lt;p&gt;画一张中国地图，标出你所在的那个省的省界，和所在的省会，标完之后，把你标的与地图进行比较，注意有哪些地方搞错了，不过地图在眼前时不要去修正，把错处及如何修正都记在脑子里，然后丢幵地图再画一张。错误越多就越需要重复做这个练习。&lt;/p&gt;
&lt;p&gt;在你有把握画出整个中国之后就画整个亚洲，然后画南美洲、欧洲以及其他的洲。要画得多详细由你自己决定。&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://dword.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="观察力" scheme="https://dword.top/tags/%E8%A7%82%E5%AF%9F%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>解压文件(选自python绝技)</title>
    <link href="https://dword.top/%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6-%E9%80%89%E8%87%AApython%E7%BB%9D%E6%8A%80.html"/>
    <id>https://dword.top/解压文件-选自python绝技.html</id>
    <published>2018-06-14T16:00:00.000Z</published>
    <updated>2018-06-25T17:24:49.360Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;破解zip文件需要用到python中的zipfile库，实例化ZipFile类，ZipFile类是用来创建和读取zip文件的，调用其extractall()方法。<br><br><strong><em>extractall([path[,member[,path[,pwd]]])</em></strong>  </p><ul><li>path:解压缩的目录  </li><li>member:需要解压缩的文件列表  </li><li>pwd:当zip文件有密码是需要该选项  </li></ul><p>看下面实例:<br></p><p>>&gt;&gt; import zipfile<br>>&gt;&gt; zipfile = zipfile.ZipFile(r’D:\pycharm_obj\abc.zip’)<br>>&gt;&gt; zipfile.extractall(‘1234’)  </p><p>运行以后显示密码不正确，查看以后发现是一个字符一个字符读取，但我看资料大多都这样写不知道怎么回事，应该是版本有点变化了，我的版本是3.6。</p><p>最后附上一个简单的小破解程序，对原书的做了一些小修改。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个破解的方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extgractfile</span><span class="params">(zfile, password)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        zfile.extractall(pwd=password.encode())</span><br><span class="line">        print(password+<span class="string">"++++++++++++++++++++++++++++++"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> password</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(k)</span>:</span></span><br><span class="line">    zfile = zipfile.ZipFile(<span class="string">r'abc.zip'</span>)</span><br><span class="line">    passfile = open(<span class="string">r'dictionary.txt'</span>)</span><br><span class="line">    </span><br><span class="line">    list = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> passfile.readline():</span><br><span class="line">        pas = line.strip(<span class="string">'\n'</span>)</span><br><span class="line">        list.append(pas)</span><br><span class="line">    <span class="comment">#没办法一个一个读取，只能自己拼接密码了</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list)):</span><br><span class="line">        <span class="comment">#拼接到最后一个字符就退出</span></span><br><span class="line">        <span class="keyword">if</span> (i + k &gt; len(list)):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pasword =<span class="string">""</span>.join(list[i:i+k])</span><br><span class="line">        print(pasword,len(pasword))</span><br><span class="line">        t = Thread(target=extgractfile,args=(zfile, pasword))</span><br><span class="line">        t.start()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(<span class="number">4</span>)</span><br><span class="line">    <span class="comment">#可以解压传统压缩模式，默认模式不行\</span></span><br><span class="line">    <span class="comment">#加入了一个几位数密码的判读，这个不成熟，应该是某个范围的判断才更好一点</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;破解zip文件需要用到python中的zipfile库，实例化ZipFile类，ZipFile类是用来创建和读取zip文件的，调用其extractall()方法。&lt;br&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;extractall([path[,member[,path[,pwd]]])&lt;/em&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;path:解压缩的目录  &lt;/li&gt;
&lt;li&gt;member:需要解压缩的文件列表  &lt;/li&gt;
&lt;li&gt;pwd:当zip文件有密码是需要该选项  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看下面实例:&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&gt;&amp;gt;&amp;gt; import zipfile&lt;br&gt;&gt;&amp;gt;&amp;gt; zipfile = zipfile.ZipFile(r’D:\pycharm_obj\abc.zip’)&lt;br&gt;&gt;&amp;gt;&amp;gt; zipfile.extractall(‘1234’)  &lt;/p&gt;
&lt;p&gt;运行以后显示密码不正确，查看以后发现是一个字符一个字符读取，但我看资料大多都这样写不知道怎么回事，应该是版本有点变化了，我的版本是3.6。&lt;/p&gt;
&lt;p&gt;最后附上一个简单的小破解程序，对原书的做了一些小修改。&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://dword.top/categories/python/"/>
    
    
      <category term="python" scheme="https://dword.top/tags/python/"/>
    
      <category term="zipfile" scheme="https://dword.top/tags/zipfile/"/>
    
  </entry>
  
  <entry>
    <title>英语连读</title>
    <link href="https://dword.top/%E8%BF%9E%E8%AF%BB.html"/>
    <id>https://dword.top/连读.html</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2018-06-25T17:25:13.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="英语句子连读的一些发音《赖世雄-英语音标》"><a href="#英语句子连读的一些发音《赖世雄-英语音标》" class="headerlink" title="英语句子连读的一些发音《赖世雄-英语音标》"></a>英语句子连读的一些发音《赖世雄-英语音标》</h2><p>在我们熟悉音标的前提下，在听英美人整句对话的时候，还是听不懂，这里介绍一些句子连读的念法，看下面最好有音标的基础。</p><h3 id="字尾辅音-字首元音"><a href="#字尾辅音-字首元音" class="headerlink" title="字尾辅音+字首元音"></a>字尾辅音+字首元音</h3><p>短语：  </p><h4 id="p-元音"><a href="#p-元音" class="headerlink" title="[p] + 元音"></a>[p] + 元音</h4><p><font color="green" size="3">up and down</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <font color="orange" size="3">[ʌpənd ˈdaun]</font><br>上上下下  </p><p><font color="green" size="3">keep it up</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[kipɪ ˈtʌp]</font><br>坚持下去  </p><p><font color="green" size="3">stop it</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[ˈstɑpɪt]</font><br>住手  </p><h4 id="t-元音"><a href="#t-元音" class="headerlink" title="[t] + 元音"></a>[t] + 元音</h4><p><font color="green" size="3">put it on</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[pʊtɪ ˈɑn]</font><br>把它穿上  </p><p><font color="green" size="3">not at all</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[nɑtæ ˈtɔl]</font><br>一点也不  </p><p><font color="green" size="3">put it off</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[pʊtɪ ˈtɔf] </font><br>把它延期<br><a id="more"></a></p><h4 id="d-元音"><a href="#d-元音" class="headerlink" title="[d] + 元音"></a>[d] + 元音</h4><p><font color="green" size="3">stand up</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[stæn ˈdʌp]</font><br>站起来  </p><p><font color="green" size="3">good idea</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[ɡʊdaɪ ˈdiə] </font><br>好主意  </p><p><font color="green" size="3">Dad and Mom</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[dædənd ˈmɑm] </font><br>老爸和老妈</p><h4 id="k-元音"><a href="#k-元音" class="headerlink" title="[k] + 元音"></a>[k] + 元音</h4><p><font color="green" size="3">take off</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[te ˈkɔf]</font><br>起飞  </p><p><font color="green" size="3">pick it up</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[pɪkɪ ˈtʌp]</font><br>把它拾起来  </p><p><font color="green" size="3">knock him out</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[nɑkə ˈmaʊt]</font><br>把他击晕  </p><h4 id="n-元音"><a href="#n-元音" class="headerlink" title="[n] + 元音"></a>[n] + 元音</h4><p><font color="green" size="3">in an hour</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[Inə ˈnaʊr]</font><br>一个小时后  </p><p><font color="green" size="3">pen and paper</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[pɛnənd ˈpepər] </font><br>纸和笔  </p><p><font color="green" size="3">clean and tidy</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[klinənd ˈtaɪdi] </font><br>干净又整洁  </p><h4 id="r-元音"><a href="#r-元音" class="headerlink" title="[r] + 元音"></a>[r] + 元音</h4><p><font color="green" size="3">far away</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[fɑrə ˈwe]</font><br>遥远的  </p><p><font color="green" size="3">pair of shoes</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[pɛrəv ‘ʃuz] </font><br>一双鞋  </p><p><font color="green" size="3">for instance</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[fɔ ‘rɪnstəns]  </font><br>举例说明  </p><ul><li><font color="green" size="3">up and down , Dad and Mon , pen and paper 及 clean and tidy 中的and 本来要发 [ænd]的音，但在弱音节时，则发[ənd]的音。  </font><br></li><li><p><font color="green" size="3">knock him out 中 him 原本要发[hIm]的音，但在弱音节时则发[əm]的音，原有的[h]不需要念出来。  </font><br></p></li><li><p><font color="green" size="3">in an hour 中的an 本来要发[æn]的音，但在弱音节时则发[ən]的音  </font><br></p></li></ul><h3 id="字尾辅音-字首相同的辅音"><a href="#字尾辅音-字首相同的辅音" class="headerlink" title="字尾辅音 + 字首相同的辅音"></a>字尾辅音 + 字首相同的辅音</h3><p><font color="green" size="2">&lt;通常前者的辅音可省略憋气有意就可以了，只念后者的辅音。这种情况常发生在[p],[t],[k],[d],[g].&gt;</font><br></p><h4 id="p-p"><a href="#p-p" class="headerlink" title="[p] + [p]"></a>[p] + [p]</h4><p><font color="green" size="3">deep pond</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <font color="orange" size="3">[di* ‘pɑnd] </font><br>深池塘    </p><p><font color="green" size="3">stop playing</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[stɑ* ‘pleɪŋ] </font><br>停止游戏  </p><p><font color="green" size="3">keep pace</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[ki* ‘pes] </font><br>保持步速   </p><h4 id="t-t"><a href="#t-t" class="headerlink" title="[t] + [t]"></a>[t] + [t]</h4><p><font color="green" size="3">hot tea</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[hɑ* ‘ti] </font><br>热茶  </p><p><font color="green" size="3">part-time</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <font color="orange" size="3">[pɑr* ‘taɪm]</font><br>兼职的  </p><p><font color="green" size="3">at two</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[æ* ‘tu]</font><br>在两点时  </p><h4 id="k-k"><a href="#k-k" class="headerlink" title="[k] + [k]"></a>[k] + [k]</h4><p><font color="green" size="3">take care</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <font color="orange" size="3">[te* ‘kɛr]</font><br>小心  </p><p><font color="green" size="3">black coffee</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[blæ* ‘kafi] </font><br>不加奶精及糖的咖啡  </p><p><font color="green" size="3">book case</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[bʊ* kes]</font><br>书柜  </p><h4 id="d-d"><a href="#d-d" class="headerlink" title="[d] + [d]"></a>[d] + [d]</h4><p><font color="green" size="3">good day</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[gʊ* ‘de]</font><br>好日子  </p><p><font color="green" size="3">cold day</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[kol* ‘de]</font><br>寒天  </p><p><font color="green" size="3">red dress</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <font color="orange" size="3"> [rɛ* ‘drɛs]</font><br>红色的洋装  </p><h4 id="g-g"><a href="#g-g" class="headerlink" title="[g] + [g]"></a>[g] + [g]</h4><p><font color="green" size="3">big game</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <font color="orange" size="3">[bɪ* ‘gem]</font><br>大比赛   </p><p><font color="green" size="3">big graden</font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <font color="orange" size="3">[bɪ* ‘gɑrdn]</font><br>大花园  </p><p><font color="green" size="3">big gate</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3"> [bɪ* ‘get] </font><br>大门  </p><h4 id="c-t"><a href="#c-t" class="headerlink" title="[c] +[t]"></a>[c] +[t]</h4><p><font color="green" size="3">red table</font>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[rɛ* ‘tebl] </font><br>红色的子  </p><p><font color="green" size="3">round table</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[raʊn* ‘tebl]</font><br>圆桌  </p><p><font color="green" size="3">good teacher</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3"> [gʊ* ‘titʃɚ] </font><br>好老师</p><h4 id="k-g"><a href="#k-g" class="headerlink" title="[k] + [g]"></a>[k] + [g]</h4><p><font color="green" size="3">black gate</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3"> [blæ* ‘get] </font><br>黑色的门</p><h4 id="p-b"><a href="#p-b" class="headerlink" title="[p] + [b]"></a>[p] + [b]</h4><p><font color="green" size="3">cheap book</font> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="orange" size="3">[tʃi* ‘bʊk] </font><br>便宜的书  </p><h4 id="字尾-t-或字尾有-d"><a href="#字尾-t-或字尾有-d" class="headerlink" title="字尾[t] 或字尾有[d]"></a>字尾[t] 或字尾有[d]</h4><p><font color="green" size="2">&lt;通常不会读出来，而是快要念出来的时候，憋气顿息，常常听不到.&gt;</font><br></p><p><font color="green" size="3">Let me try it.</font><br>让我试试看  </p><p><font color="green" size="3">Don’t worry about it.</font><br>不要担心这个  </p><p><font color="green" size="3">Don’t get me wrong.</font><br>不要误解我  </p><p><font color="green" size="3">You don’t mean it.</font><br>你不是当真的  </p><p><font color="green" size="3">Just great. </font><br>太好了  </p><p><font color="green" size="3">It might be true. </font><br>那也许时真的  </p><p><font color="green" size="3">Good news.</font><br>好消息  </p><p><font color="green" size="3">Could be. </font><br>也许吧  </p><p><font color="green" size="3">I’m tired.</font><br>我累了  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;英语句子连读的一些发音《赖世雄-英语音标》&quot;&gt;&lt;a href=&quot;#英语句子连读的一些发音《赖世雄-英语音标》&quot; class=&quot;headerlink&quot; title=&quot;英语句子连读的一些发音《赖世雄-英语音标》&quot;&gt;&lt;/a&gt;英语句子连读的一些发音《赖世雄-英语音标》&lt;/h2&gt;&lt;p&gt;在我们熟悉音标的前提下，在听英美人整句对话的时候，还是听不懂，这里介绍一些句子连读的念法，看下面最好有音标的基础。&lt;/p&gt;
&lt;h3 id=&quot;字尾辅音-字首元音&quot;&gt;&lt;a href=&quot;#字尾辅音-字首元音&quot; class=&quot;headerlink&quot; title=&quot;字尾辅音+字首元音&quot;&gt;&lt;/a&gt;字尾辅音+字首元音&lt;/h3&gt;&lt;p&gt;短语：  &lt;/p&gt;
&lt;h4 id=&quot;p-元音&quot;&gt;&lt;a href=&quot;#p-元音&quot; class=&quot;headerlink&quot; title=&quot;[p] + 元音&quot;&gt;&lt;/a&gt;[p] + 元音&lt;/h4&gt;&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;3&quot;&gt;up and down&lt;/font&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;  &lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;[ʌpənd ˈdaun]&lt;/font&gt;&lt;br&gt;上上下下  &lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;3&quot;&gt;keep it up&lt;/font&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;[kipɪ ˈtʌp]&lt;/font&gt;&lt;br&gt;坚持下去  &lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;3&quot;&gt;stop it&lt;/font&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;[ˈstɑpɪt]&lt;/font&gt;&lt;br&gt;住手  &lt;/p&gt;
&lt;h4 id=&quot;t-元音&quot;&gt;&lt;a href=&quot;#t-元音&quot; class=&quot;headerlink&quot; title=&quot;[t] + 元音&quot;&gt;&lt;/a&gt;[t] + 元音&lt;/h4&gt;&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;3&quot;&gt;put it on&lt;/font&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;[pʊtɪ ˈɑn]&lt;/font&gt;&lt;br&gt;把它穿上  &lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;3&quot;&gt;not at all&lt;/font&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;[nɑtæ ˈtɔl]&lt;/font&gt;&lt;br&gt;一点也不  &lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;3&quot;&gt;put it off&lt;/font&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;[pʊtɪ ˈtɔf] &lt;/font&gt;&lt;br&gt;把它延期&lt;br&gt;
    
    </summary>
    
      <category term="英语" scheme="https://dword.top/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="英语" scheme="https://dword.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://dword.top/%E6%8E%92%E5%BA%8F.html"/>
    <id>https://dword.top/排序.html</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-08-02T05:28:46.553Z</updated>
    
    <content type="html"><![CDATA[<h4 id="c-数组的逆序以及汉字的输出操作"><a href="#c-数组的逆序以及汉字的输出操作" class="headerlink" title="c++数组的逆序以及汉字的输出操作"></a>c++数组的逆序以及汉字的输出操作</h4><h5 id="首先是数组的逆序操作"><a href="#首先是数组的逆序操作" class="headerlink" title="首先是数组的逆序操作."></a>首先是数组的逆序操作.</h5><ul><li>获取数组的首地址跟末地址</li><li>利用中间值依次交换</li><li>最后输出逆序以后的数组  </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nixu</span><span class="params">(<span class="keyword">int</span> str[],<span class="keyword">int</span> len)</span><span class="comment">//数组的逆序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ip = &amp;str[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> *ip1 = &amp;str[len<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">while</span> (ip&lt;ip1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *ip;</span><br><span class="line">*ip = *ip1;</span><br><span class="line">*ip1 = temp;</span><br><span class="line"></span><br><span class="line">ip++;</span><br><span class="line">ip1--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, str[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h5 id="求一个数组中第二大的数。"><a href="#求一个数组中第二大的数。" class="headerlink" title="求一个数组中第二大的数。"></a>求一个数组中第二大的数。</h5><ul><li>首先定义两个指针指向首地址跟下一个地址</li><li>假设max是最大值，s_max是第二大值</li><li>第一个判断得到的是否是最大值。  </li><li>第二个判断第二大值是否仅次于最大值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbxs</span><span class="params">(<span class="keyword">int</span> *str，<span class="keyword">int</span> lens)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//定义两个指针</span></span><br><span class="line"><span class="keyword">int</span>* max = str;</span><br><span class="line"><span class="keyword">int</span> *s_max = ++str;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lens - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*max &lt; *(str + i))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ip = *s_max;</span><br><span class="line">*s_max = *max;</span><br><span class="line">*max = *(str + i);</span><br><span class="line">*(str + i) = ip;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*max &gt; *(str + i) &amp;&amp; *s_max &lt; *(str + i))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ipp=*s_max;</span><br><span class="line">*s_max = *(str + i);</span><br><span class="line">*(str+i)=ipp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *s_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对汉字进行输出"><a href="#对汉字进行输出" class="headerlink" title="对汉字进行输出"></a>对汉字进行输出</h5><p>因为一个汉字占两个字节或者更多的字节数，所以输出一个字一定是几个字节拼凑得出一个字。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">china_string</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *ip = str;</span><br><span class="line"><span class="keyword">while</span> (*ip)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c\n"</span>,*ip,*(ip+<span class="number">1</span>) );</span><br><span class="line">ip +=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对汉字字符串进行逆序操作"><a href="#对汉字字符串进行逆序操作" class="headerlink" title="对汉字字符串进行逆序操作"></a>对汉字字符串进行逆序操作</h5><p>整体思路跟前面的不变，只是指针移动的字节数是一个汉字占用的字节数。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">china_string_server</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">short</span> *ip = &amp;str[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">short</span> *ip1 = &amp;str[<span class="built_in">strlen</span>(str)<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">while</span> (ip&lt;ip1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">short</span> temp = *ip;</span><br><span class="line">*ip = *ip1;</span><br><span class="line">*ip1 = temp;</span><br><span class="line"></span><br><span class="line">ip++;</span><br><span class="line">ip1--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="求数组中最大值。"><a href="#求数组中最大值。" class="headerlink" title="求数组中最大值。"></a>求数组中最大值。</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxs</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> lens)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = *a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lens; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; *(a+i))</span><br><span class="line">max = *(a+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好多东西零零散散的都快忘干净了，写的不是很好，有好想法的小伙伴多提意见。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;c-数组的逆序以及汉字的输出操作&quot;&gt;&lt;a href=&quot;#c-数组的逆序以及汉字的输出操作&quot; class=&quot;headerlink&quot; title=&quot;c++数组的逆序以及汉字的输出操作&quot;&gt;&lt;/a&gt;c++数组的逆序以及汉字的输出操作&lt;/h4&gt;&lt;h5 id=&quot;首先是数组的逆序操作&quot;&gt;&lt;a href=&quot;#首先是数组的逆序操作&quot; class=&quot;headerlink&quot; title=&quot;首先是数组的逆序操作.&quot;&gt;&lt;/a&gt;首先是数组的逆序操作.&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;获取数组的首地址跟末地址&lt;/li&gt;
&lt;li&gt;利用中间值依次交换&lt;/li&gt;
&lt;li&gt;最后输出逆序以后的数组  &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;nixu&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; str[],&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//数组的逆序&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ip = &amp;amp;str[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *ip1 = &amp;amp;str[len&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (ip&amp;lt;ip1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; temp = *ip;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		*ip = *ip1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		*ip1 = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ip++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ip1--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; len; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d\n&quot;&lt;/span&gt;, str[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="c++" scheme="https://dword.top/categories/c/"/>
    
    
      <category term="排序" scheme="https://dword.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>链表结构实现</title>
    <link href="https://dword.top/%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.html"/>
    <id>https://dword.top/链表结构.html</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-08-02T05:30:56.879Z</updated>
    
    <content type="html"><![CDATA[<p>最近清理磁盘，发现以前自己的一些学习痕迹，当时留下的汇编代码现在看反而自己有点懵，所以，学习的一些心得是，不是你到底学了多少，一定是记住了多少，想想以前花了大量时间研究学习的都忘记，心里很不是滋味。为了不让它消失，也算对自己学习的一些回报就把它收录了进来，供大家参考。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inversion</span><span class="params">(<span class="keyword">int</span> *p)</span></span>;<span class="comment">//逆序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sersion</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> len)</span></span>;<span class="comment">//冒泡排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> <span class="title">List</span> //<span class="title">list</span>模型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*PNODE,NODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建列表</span></span><br><span class="line"><span class="function">PNODE <span class="title">create_list</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_list</span><span class="params">(PNODE phead)</span></span>;</span><br><span class="line"><span class="comment">//判断是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE phead)</span></span>;</span><br><span class="line"><span class="comment">//长度or是否饱和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_list</span><span class="params">(PNODE)</span></span>;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert_list</span><span class="params">(PNODE, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_list</span><span class="params">(PNODE, <span class="keyword">int</span>, <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_list</span><span class="params">(PNODE)</span></span>;</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建list</span></span><br><span class="line"><span class="function">PNODE <span class="title">create_list</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len, i;</span><br><span class="line">PNODE current;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入个数"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;len);</span><br><span class="line">PNODE phead = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span> (phead == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分配失败！"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">phead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">current = phead;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">PNODE pnew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分配失败！"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pnew-&gt;data = i;</span><br><span class="line">current-&gt;next = pnew;</span><br><span class="line">pnew-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">current = pnew;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> phead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse_list</span><span class="params">(PNODE phead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PNODE p = phead-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_empty</span><span class="params">(PNODE phead)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (phead-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//长度or是否饱和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length_list</span><span class="params">(PNODE phead)</span></span>&#123;</span><br><span class="line">PNODE p = phead-&gt;next;</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">len++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert_list</span><span class="params">(PNODE phead, <span class="keyword">int</span> pox, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">PNODE p;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; phead != <span class="literal">NULL</span> &amp;&amp; i &lt; pox - <span class="number">1</span>; phead = phead-&gt;next, i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while (phead != NULL&amp;&amp; i &lt; pox - 1)&#123;</span></span><br><span class="line"><span class="comment">++i;</span></span><br><span class="line"><span class="comment">phead = phead-&gt;next;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span> (phead==<span class="literal">NULL</span>||i&gt;pox)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">PNODE pnew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span> (pnew == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分配失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    p=phead-&gt;next;</span><br><span class="line">phead-&gt;next = pnew;</span><br><span class="line">pnew-&gt;data = val;</span><br><span class="line">pnew-&gt;next = p;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">delete_list</span><span class="params">(PNODE phead, <span class="keyword">int</span> pos, <span class="keyword">int</span> *val)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">PNODE p = phead;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">NULL</span> != p-&gt;next &amp;&amp; i &lt; pos - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i&gt;pos - <span class="number">1</span> || <span class="literal">NULL</span> == p-&gt;next)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">PNODE q = p-&gt;next;</span><br><span class="line">*val = q-&gt;data;</span><br><span class="line"><span class="comment">//删除p节点后main的节点</span></span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line">q = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_list</span><span class="params">(PNODE phead)</span></span>&#123;</span><br><span class="line">PNODE p = phead-&gt;next;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">PNODE current = p-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (current!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data &lt; current-&gt;data)</span><br><span class="line">&#123;</span><br><span class="line">tmp=p-&gt;data;</span><br><span class="line">p-&gt;data = current-&gt;data;</span><br><span class="line">current-&gt;data = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d   %d\n", p-&gt;data, current-&gt;data);</span></span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sersion</span><span class="params">(<span class="keyword">int</span> *p,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p[i ] &lt; p[j])</span><br><span class="line">&#123;</span><br><span class="line">max = p[i ];</span><br><span class="line">p[i ] = p[j];</span><br><span class="line">p[j] = max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf("%d\n,%d\n",p[i-1], p[j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">PNODE head = create_list();     <span class="comment">//创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if (!is_empty(head))   //是否为空</span></span><br><span class="line"><span class="comment">//printf("列表为空");</span></span><br><span class="line"><span class="comment">//printf("长度为%d", length_list(head));  //长度</span></span><br><span class="line"><span class="comment">//sort_list(head);     //排序</span></span><br><span class="line"><span class="keyword">if</span> (insert_list(head,<span class="number">6</span>,<span class="number">22</span>))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"插入成功\n"</span>);</span><br><span class="line">traverse_list(head);   <span class="comment">//遍历</span></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近清理磁盘，发现以前自己的一些学习痕迹，当时留下的汇编代码现在看反而自己有点懵，所以，学习的一些心得是，不是你到底学了多少，一定是记住了多少，想想以前花了大量时间研究学习的都忘记，心里很不是滋味。为了不让它消失，也算对自己学习的一些回报就把它收录了进来，供大家参考。&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt;  _CRT_SECURE_NO_WARNINGS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdbool.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inversion&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//逆序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sersion&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; len)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//冒泡排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt; //&lt;span class=&quot;title&quot;&gt;list&lt;/span&gt;模型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;List&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;next&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;*PNODE,NODE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;PNODE &lt;span class=&quot;title&quot;&gt;create_list&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//遍历&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;traverse_list&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PNODE phead)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//判断是否为空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;is_empty&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PNODE phead)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//长度or是否饱和&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;length_list&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PNODE)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//插入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;insert_list&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PNODE, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//删除&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;delete_list&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PNODE, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//排序&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;sort_list&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PNODE)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="c++" scheme="https://dword.top/categories/c/"/>
    
    
      <category term="数据类型" scheme="https://dword.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>栈结构实现</title>
    <link href="https://dword.top/%E6%A0%88%E7%BB%93%E6%9E%84.html"/>
    <id>https://dword.top/栈结构.html</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-08-02T05:29:50.430Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>      //定义栈模型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">PNODE TOP;</span><br><span class="line">PNODE BUTTOM;</span><br><span class="line">&#125;*PSTACK,STACK;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">栈定义的模型</span></span><br><span class="line"><span class="comment">初始化方法，压入栈的方法，出栈的方法，遍历的方法，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//初始化栈的操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_stack</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="comment">//压入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_stack</span><span class="params">(PSTACK, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_stack</span><span class="params">(PSTACK, <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="comment">//是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK)</span></span>;</span><br><span class="line"><span class="comment">//clear;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现上述栈的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_stack</span><span class="params">(PSTACK phead)</span></span>&#123;</span><br><span class="line">PNODE <span class="built_in">stack</span> = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"创建失败！"</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">phead-&gt;BUTTOM = <span class="built_in">stack</span>;</span><br><span class="line">phead-&gt;TOP = phead-&gt;BUTTOM;</span><br><span class="line">phead-&gt;TOP-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_stack</span><span class="params">(PSTACK phead, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">PNODE pnew = (PNODE)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(NODE));</span><br><span class="line">pnew-&gt;data = val;</span><br><span class="line">pnew-&gt;next = phead-&gt;TOP;</span><br><span class="line">phead-&gt;TOP = pnew;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_stack</span><span class="params">(PSTACK phead, <span class="keyword">int</span> *val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (empty(phead))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PNODE p = phead-&gt;TOP;</span><br><span class="line">*val = p-&gt;data;</span><br><span class="line">phead-&gt;TOP = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(PSTACK phead)</span></span>&#123;</span><br><span class="line">PNODE p = phead-&gt;TOP;</span><br><span class="line"><span class="keyword">while</span> (phead-&gt;BUTTOM!=p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">(PSTACK phead)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (phead-&gt;BUTTOM == phead-&gt;TOP)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//clear</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(PSTACK phead)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (empty(phead))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">PNODE p = phead-&gt;TOP;</span><br><span class="line"><span class="keyword">while</span> (p != phead-&gt;BUTTOM)</span><br><span class="line">&#123;</span><br><span class="line">phead-&gt;TOP = p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = phead-&gt;TOP;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">STACK <span class="built_in">stack</span>;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">init_stack(&amp;<span class="built_in">stack</span>);   <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">if</span> (empty(&amp;<span class="built_in">stack</span>))  <span class="comment">//</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"空stack\n"</span>);</span><br><span class="line">push_stack(&amp;<span class="built_in">stack</span>, <span class="number">1</span>);<span class="comment">//push</span></span><br><span class="line">push_stack(&amp;<span class="built_in">stack</span>, <span class="number">2</span>);</span><br><span class="line">push_stack(&amp;<span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line">traverse(&amp;<span class="built_in">stack</span>);   <span class="comment">//遍历</span></span><br><span class="line">pop_stack(&amp;<span class="built_in">stack</span>, &amp;val);</span><br><span class="line">clear(&amp;<span class="built_in">stack</span>);  <span class="comment">//clear</span></span><br><span class="line">pop_stack(&amp;<span class="built_in">stack</span>, &amp;val);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, val);</span><br><span class="line">pop_stack(&amp;<span class="built_in">stack</span>, &amp;val);</span><br><span class="line">pop_stack(&amp;<span class="built_in">stack</span>,&amp;val);   <span class="comment">//pop</span></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt;  _CRT_SECURE_NO_WARNINGS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdbool.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Stack&lt;/span&gt;      //定义栈模型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	PNODE TOP;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	PNODE BUTTOM;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;*PSTACK,STACK;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;栈定义的模型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;初始化方法，压入栈的方法，出栈的方法，遍历的方法，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//初始化栈的操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init_stack&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PSTACK)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//压入栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;push_stack&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PSTACK, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//出栈&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pop_stack&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PSTACK, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//遍历&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;traverse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PSTACK)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//是否为空&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PSTACK)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//clear;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(PSTACK)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="c++" scheme="https://dword.top/categories/c/"/>
    
    
      <category term="数据类型" scheme="https://dword.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>队列结构实现</title>
    <link href="https://dword.top/%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://dword.top/队列实现.html</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-08-02T05:30:34.193Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> * pBase;</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line">&#125;QUEUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">队列的实现</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_queue</span><span class="params">(QUEUE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_queue</span><span class="params">(QUEUE *phead)</span></span>&#123;</span><br><span class="line">phead-&gt;pBase = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">6</span>);</span><br><span class="line">phead-&gt;front = <span class="number">0</span>;</span><br><span class="line">phead-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">en_queue</span><span class="params">(QUEUE *,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">full_queue</span><span class="params">(QUEUE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_timy</span><span class="params">(QUEUE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">de_queue</span><span class="params">(QUEUE *, <span class="keyword">int</span>*)</span></span>;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">en_queue</span><span class="params">(QUEUE *phead,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (full_queue(phead))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">phead-&gt;pBase[phead-&gt;rear] = val;</span><br><span class="line">phead-&gt;rear = (phead-&gt;rear + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">de_queue</span><span class="params">(QUEUE *phead, <span class="keyword">int</span> *val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_timy(phead))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">*val = phead-&gt;pBase[phead-&gt;front];</span><br><span class="line">phead-&gt;front = (phead-&gt;front + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_timy</span><span class="params">(QUEUE *phead)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (phead-&gt;front == phead-&gt;rear)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是否饱和</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">full_queue</span><span class="params">(QUEUE * phead)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (phead-&gt;front==(phead-&gt;rear+<span class="number">1</span>)%<span class="number">6</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">taverse_queue</span><span class="params">(QUEUE *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">taverse_queue</span><span class="params">(QUEUE * phead)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> f = phead-&gt;front;</span><br><span class="line"><span class="keyword">int</span> r = phead-&gt;rear;</span><br><span class="line"><span class="keyword">if</span> (is_timy(phead))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">while</span> (f!=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, phead-&gt;pBase[f]);</span><br><span class="line">f = (f + <span class="number">1</span>) % <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">QUEUE <span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">init_queue(&amp;<span class="built_in">queue</span>);  <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">if</span> (is_timy(&amp;<span class="built_in">queue</span>))     <span class="comment">//是否为空</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"空队列"</span>);</span><br><span class="line">en_queue(&amp;<span class="built_in">queue</span>, <span class="number">1</span>);     <span class="comment">//入队</span></span><br><span class="line">en_queue(&amp;<span class="built_in">queue</span>, <span class="number">2</span>);</span><br><span class="line">en_queue(&amp;<span class="built_in">queue</span>, <span class="number">3</span>);</span><br><span class="line">en_queue(&amp;<span class="built_in">queue</span>, <span class="number">4</span>);</span><br><span class="line">en_queue(&amp;<span class="built_in">queue</span>, <span class="number">5</span>);</span><br><span class="line">taverse_queue(&amp;<span class="built_in">queue</span>);   <span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">if</span> (full_queue(&amp;<span class="built_in">queue</span>))      <span class="comment">//是否饱和</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"饱和"</span>);</span><br><span class="line">en_queue(&amp;<span class="built_in">queue</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">if</span> (full_queue(&amp;<span class="built_in">queue</span>))     <span class="comment">//是否饱和</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"饱和"</span>);</span><br><span class="line">de_queue(&amp;<span class="built_in">queue</span>, &amp;val);</span><br><span class="line">de_queue(&amp;<span class="built_in">queue</span>, &amp;val);</span><br><span class="line">de_queue(&amp;<span class="built_in">queue</span>, &amp;val);</span><br><span class="line">de_queue(&amp;<span class="built_in">queue</span>, &amp;val);</span><br><span class="line">de_queue(&amp;<span class="built_in">queue</span>, &amp;val);</span><br><span class="line">de_queue(&amp;<span class="built_in">queue</span>, &amp;val);</span><br><span class="line">taverse_queue(&amp;<span class="built_in">queue</span>);    </span><br><span class="line">de_queue(&amp;<span class="built_in">queue</span>, &amp;val);  <span class="comment">//出队</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt;  _CRT_SECURE_NO_WARNINGS&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdbool.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Queue&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; * pBase;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; front;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rear;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;QUEUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;队列的实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//初始化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init_queue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QUEUE *)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init_queue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QUEUE *phead)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	phead-&amp;gt;pBase = (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) * &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	phead-&amp;gt;front = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	phead-&amp;gt;rear = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//入队&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;en_queue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QUEUE *,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;full_queue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QUEUE *)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;is_timy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QUEUE *)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;de_queue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(QUEUE *, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="c++" scheme="https://dword.top/categories/c/"/>
    
    
      <category term="数据类型" scheme="https://dword.top/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>建立连接</title>
    <link href="https://dword.top/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html"/>
    <id>https://dword.top/三次握手，四次挥手.html</id>
    <published>2017-12-11T16:00:00.000Z</published>
    <updated>2018-12-24T02:29:05.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tcp的三次握手"><a href="#tcp的三次握手" class="headerlink" title="tcp的三次握手"></a>tcp的三次握手</h3><p><a href="http://img3.imgtn.bdimg.com/it/u=877665853,860765078&amp;fm=214&amp;gp=0.jpg" target="_blank" rel="noopener">http://img3.imgtn.bdimg.com/it/u=877665853,860765078&amp;fm=214&amp;gp=0.jpg</a></p><ol><li><p>客户端发送一个带SYN标志的TCP报文到服务器。SYN位表示连接请求。序号是1000（随机数，此处1000），这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。</p></li><li><p>服务器端回应客户端,同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求SYN，序号是8000（实际也是一个随机数，此处以8000为例），同时声明最大尺寸为1024。</p></li><li>客户端对服务器的连接请求进行应答，确认ack序号是8001</li><li>在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等.在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，客户端的telnet程序收到RST段后报告错误Connection refused。<a id="more"></a><h3 id="tcp的四次挥手"><a href="#tcp的四次挥手" class="headerlink" title="tcp的四次挥手"></a>tcp的四次挥手</h3>由于TCP连接是可以双向通信的（全双工），因此每个方向都必须单独进行关闭。</li></ol><p>这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li><p>客户端发出段7，FIN位表示关闭连接的请求。</p></li><li><p>服务器发出段8，应答客户端的关闭连接请求。</p></li><li><p>服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。</p></li><li><p>客户端发出段10，应答服务器的关闭连接请求。</p></li></ol><h3 id="tcp十种状态"><a href="#tcp十种状态" class="headerlink" title="tcp十种状态"></a>tcp十种状态</h3><h5 id="握手期间的状态"><a href="#握手期间的状态" class="headerlink" title="握手期间的状态"></a>握手期间的状态</h5><ol><li><p>CLOSED：<br>表示关闭状态（初始状态）。</p></li><li><p>LISTEN：<br>该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接</p></li><li><p>SYN_SENT：<br>这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</p></li><li><p>SYN_RCVD:<br>该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。</p></li><li><p>ESTABLISHED：<br>表示连接已经建立。</p></li></ol><h5 id="挥手期间状态"><a href="#挥手期间状态" class="headerlink" title="挥手期间状态"></a>挥手期间状态</h5><ol><li><p>FIN_WAIT_1：<br> FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：<br> FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。 FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。</p></li><li><p>FIN_WAIT_2：<br><br>主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。</p></li><li><p>CLOSE_WAIT:<br> 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。</p></li><li><p>TIME_WAIT: <br>表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</p></li><li><p>LAST_ACK:<br>该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。</p></li></ol><h3 id="第十一种状态"><a href="#第十一种状态" class="headerlink" title="第十一种状态"></a>第十一种状态</h3><ol><li>CLOSING: <br>这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;tcp的三次握手&quot;&gt;&lt;a href=&quot;#tcp的三次握手&quot; class=&quot;headerlink&quot; title=&quot;tcp的三次握手&quot;&gt;&lt;/a&gt;tcp的三次握手&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://img3.imgtn.bdimg.com/it/u=877665853,860765078&amp;amp;fm=214&amp;amp;gp=0.jpg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://img3.imgtn.bdimg.com/it/u=877665853,860765078&amp;amp;fm=214&amp;amp;gp=0.jpg&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;客户端发送一个带SYN标志的TCP报文到服务器。SYN位表示连接请求。序号是1000（随机数，此处1000），这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器端回应客户端,同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求SYN，序号是8000（实际也是一个随机数，此处以8000为例），同时声明最大尺寸为1024。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;客户端对服务器的连接请求进行应答，确认ack序号是8001&lt;/li&gt;
&lt;li&gt;在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等.在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，客户端的telnet程序收到RST段后报告错误Connection refused。
    
    </summary>
    
      <category term="-python" scheme="https://dword.top/categories/python/"/>
    
    
      <category term="-网络" scheme="https://dword.top/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>函数笔记</title>
    <link href="https://dword.top/%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0.html"/>
    <id>https://dword.top/函数笔记.html</id>
    <published>2017-10-22T16:00:00.000Z</published>
    <updated>2018-06-25T17:24:40.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="numpy中函数"><a href="#numpy中函数" class="headerlink" title="numpy中函数"></a>numpy中函数</h2><h3 id="min-用法"><a href="#min-用法" class="headerlink" title="min()用法"></a><font color="orange" size="3">min()用法</font><br></h3><p><font color="green" size="2">&lt;求指定维度的最小值，默认求所有值的最小值&gt;</font><br></p><ul><li><p>min(): 无参，返回所有中的最小值  </p></li><li><p>min(0):&nbsp; 等价于 axis=0, 每列的最小值 </p></li><li><p>min(1):&nbsp;等价于 axis=1,每行的最小值</p></li></ul><h3 id="max-用法"><a href="#max-用法" class="headerlink" title="max()用法"></a><font color="orange" size="3"><strong>max()用法</strong></font><br></h3><p><font color="green" size="2">&lt;求指定维度的最大值，默认求所有值的最大值&gt;</font><br></p><ul><li>max(): 无参，所有中的最大值</li><li>max(0):每列的最大值</li><li>max(1):每行的最小值<a id="more"></a><h3 id="sum-用法"><a href="#sum-用法" class="headerlink" title="sum()用法"></a><font color="orange" size="3"><strong>sum()用法</strong></font><br></h3><font color="green" size="2">&lt;求给定轴上的元素的和&gt;</font><br></li><li>sum(axis=0): 求每列上的元素的和，返回一行</li><li>sum(axis=1): 求每行上元素的和，返回一列</li></ul><h3 id="tile-用法"><a href="#tile-用法" class="headerlink" title="tile()用法"></a><font color="orange" size="3"><strong>tile()用法</strong></font><br></h3><p><font color="green" size="2">&lt;重复某个数组n次&gt;</font><br></p><ul><li>tile(a,2)==tile(a,(1,2)) 重复两次一行</li><li>tile(a,(2,1) 生成一个二行一列数组</li></ul><h3 id="argsort-用法"><a href="#argsort-用法" class="headerlink" title="argsort()用法"></a><font color="orange" size="3"><strong>argsort()用法</strong></font><br></h3><p><font color="green" size="2">&lt;对矩阵进行排序，返回从小到大的索引矩阵&gt;</font><br><br><strong>二维矩阵</strong></p><ul><li>argsort(x,axis=0) 按列排序，返回所有索引矩阵</li><li>argsort(x,axis=1) 按行排序，返回所有索引矩阵<br><strong>一维</strong></li><li>argsort(x) 按列排序，返回所有从小到大索引矩阵</li><li>argsort(-x) 按列排序，返回所有从大到小索引矩阵</li></ul><h3 id="shape-用法"><a href="#shape-用法" class="headerlink" title="shape()用法"></a><font color="orange" size="3"><strong>shape()用法</strong></font><br></h3><p><font color="green" size="2">&lt;返回指定维度的长度&gt;</font><br></p><ul><li>shape([1],[2]) 返回(2L,1L)</li><li>shape(3) 返回()</li><li>shape[0] 返回第一维度长度</li></ul><hr><h2 id="matplotlib中函数"><a href="#matplotlib中函数" class="headerlink" title="matplotlib中函数"></a>matplotlib中函数</h2><h3 id="zeros-用法"><a href="#zeros-用法" class="headerlink" title="zeros()用法"></a><font color="orange" size="3"><strong>zeros()用法</strong></font><br></h3><p><font color="green" size="2">&lt;生成一个全为的0矩阵的函数&gt;</font><br></p><ul><li>zeros(m,n);生成一个m*n的零矩阵</li><li>zeros(m);生成一个m*m的零矩阵</li><li>zeros(m,n,k…);生成一个m <em> n </em> k …的零矩阵</li><li>zeros(size \ shape(A));生成一个与矩阵A的维度一致的零矩阵</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;numpy中函数&quot;&gt;&lt;a href=&quot;#numpy中函数&quot; class=&quot;headerlink&quot; title=&quot;numpy中函数&quot;&gt;&lt;/a&gt;numpy中函数&lt;/h2&gt;&lt;h3 id=&quot;min-用法&quot;&gt;&lt;a href=&quot;#min-用法&quot; class=&quot;headerlink&quot; title=&quot;min()用法&quot;&gt;&lt;/a&gt;&lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;min()用法&lt;/font&gt;&lt;br&gt;&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;2&quot;&gt;&amp;lt;求指定维度的最小值，默认求所有值的最小值&amp;gt;&lt;/font&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;min(): 无参，返回所有中的最小值  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;min(0):&amp;nbsp; 等价于 axis=0, 每列的最小值 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;min(1):&amp;nbsp;等价于 axis=1,每行的最小值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;max-用法&quot;&gt;&lt;a href=&quot;#max-用法&quot; class=&quot;headerlink&quot; title=&quot;max()用法&quot;&gt;&lt;/a&gt;&lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;&lt;strong&gt;max()用法&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;green&quot; size=&quot;2&quot;&gt;&amp;lt;求指定维度的最大值，默认求所有值的最大值&amp;gt;&lt;/font&gt;&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;max(): 无参，所有中的最大值&lt;/li&gt;
&lt;li&gt;max(0):每列的最大值&lt;/li&gt;
&lt;li&gt;max(1):每行的最小值
    
    </summary>
    
      <category term="随记" scheme="https://dword.top/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="numpy" scheme="https://dword.top/tags/numpy/"/>
    
      <category term="matplotlib" scheme="https://dword.top/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>常见排序算法</title>
    <link href="https://dword.top/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.html"/>
    <id>https://dword.top/常用算法.html</id>
    <published>2017-10-10T16:00:00.000Z</published>
    <updated>2018-12-24T02:26:06.382Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见时间复杂度之间的关系"><a href="#常见时间复杂度之间的关系" class="headerlink" title="常见时间复杂度之间的关系"></a>常见时间复杂度之间的关系</h3><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n2) &lt; O(n3) &lt; O(2n) &lt; O(n!) &lt; O(nn)</p><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。</p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="冒泡排序算法的运作如下："><a href="#冒泡排序算法的运作如下：" class="headerlink" title="冒泡排序算法的运作如下："></a>冒泡排序算法的运作如下：</h4><ol><li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(alist)-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>)<span class="symbol">:</span></span><br><span class="line">        <span class="comment"># j表示每次遍历需要比较的次数，是逐渐减小的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j)<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]<span class="symbol">:</span></span><br><span class="line">                alist[i], alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>], alist[i]</span><br></pre></td></tr></table></figure></li></ol><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定<a id="more"></a><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="选择排序算法的运作方式"><a href="#选择排序算法的运作方式" class="headerlink" title="选择排序算法的运作方式"></a>选择排序算法的运作方式</h4>（Selection sort）是一种简单直观的排序算法。它的工作原理如下。</li><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾(第二个位置)。</li><li>以此类推，直到所有元素均排序完毕。<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(alist)</span></span><span class="symbol">:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># 需要进行n-1次选择操作</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n-<span class="number">1</span>)<span class="symbol">:</span></span><br><span class="line">        <span class="comment"># 记录最小位置</span></span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="comment"># 从i+1位置到末尾选择出最小数据</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n)<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[min_index]<span class="symbol">:</span></span><br><span class="line">                min_index = j</span><br><span class="line">        <span class="comment"># 如果选择出的数据不在正确位置，进行交换</span></span><br><span class="line">        <span class="keyword">if</span> min_index != <span class="symbol">i:</span></span><br><span class="line">            alist[i], alist[min_index] = alist[min_index], alist[i]</span><br></pre></td></tr></table></figure></li></ul><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>最优时间复杂度：O(n2)(发现没有可以和第一个交换的，但不确定后面的顺序，依然得继续)</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定（考虑升序每次选择最大的情况）</li></ul><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(alist)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="comment"># 从第二个位置，即下标为1的元素开始向前插入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(alist))<span class="symbol">:</span></span><br><span class="line">        <span class="comment"># 从第i个元素开始向前比较，如果小于前一个元素，交换位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, <span class="number">0</span>, -<span class="number">1</span>)<span class="symbol">:</span></span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[j-<span class="number">1</span>]<span class="symbol">:</span></span><br><span class="line">                alist[j], alist[j-<span class="number">1</span>] = alist[j-<span class="number">1</span>], alist[j]</span><br></pre></td></tr></table></figure></p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：稳定</li></ul><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort）</p><ul><li>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小</li><li>然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">def quick_sort(alist, <span class="keyword">start</span>, <span class="keyword">end</span>):</span><br><span class="line">    <span class="string">"""快速排序"""</span></span><br><span class="line"></span><br><span class="line">    # 递归的退出条件</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">start</span> &gt;= <span class="keyword">end</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    # 设定起始元素为要寻找位置的基准元素</span><br><span class="line">    <span class="keyword">mid</span> = alist[<span class="keyword">start</span>]</span><br><span class="line"></span><br><span class="line">    # <span class="keyword">low</span>为序列左边的由左向右移动的游标</span><br><span class="line">    <span class="keyword">low</span> = <span class="keyword">start</span></span><br><span class="line"></span><br><span class="line">    # <span class="keyword">high</span>为序列右边的由右向左移动的游标</span><br><span class="line">    <span class="keyword">high</span> = <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">low</span> &lt; <span class="keyword">high</span>:</span><br><span class="line">        # 如果<span class="keyword">low</span>与<span class="keyword">high</span>未重合，<span class="keyword">high</span>指向的元素不比基准元素小，则<span class="keyword">high</span>向左移动</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">low</span> &lt; <span class="keyword">high</span> <span class="keyword">and</span> alist[<span class="keyword">high</span>] &gt;= <span class="keyword">mid</span>:</span><br><span class="line">            <span class="keyword">high</span> -= <span class="number">1</span></span><br><span class="line">        # 将<span class="keyword">high</span>指向的元素放到<span class="keyword">low</span>的位置上</span><br><span class="line">        alist[<span class="keyword">low</span>] = alist[<span class="keyword">high</span>]</span><br><span class="line"></span><br><span class="line">        # 如果<span class="keyword">low</span>与<span class="keyword">high</span>未重合，<span class="keyword">low</span>指向的元素比基准元素小，则<span class="keyword">low</span>向右移动</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">low</span> &lt; <span class="keyword">high</span> <span class="keyword">and</span> alist[<span class="keyword">low</span>] &lt; <span class="keyword">mid</span>:</span><br><span class="line">            <span class="keyword">low</span> += <span class="number">1</span></span><br><span class="line">        # 将<span class="keyword">low</span>指向的元素放到<span class="keyword">high</span>的位置上</span><br><span class="line">        alist[<span class="keyword">high</span>] = alist[<span class="keyword">low</span>]</span><br><span class="line"></span><br><span class="line">    # 退出循环后，<span class="keyword">low</span>与<span class="keyword">high</span>重合，此时所指位置为基准元素的正确位置</span><br><span class="line">    # 将基准元素放到该位置</span><br><span class="line">    alist[<span class="keyword">low</span>] = <span class="keyword">mid</span></span><br><span class="line"></span><br><span class="line">    # 对基准元素左边的子序列进行快速排序</span><br><span class="line">    quick_sort(alist, <span class="keyword">start</span>, <span class="keyword">low</span><span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    # 对基准元素右边的子序列进行快速排序</span><br><span class="line">    quick_sort(alist, <span class="keyword">low</span>+<span class="number">1</span>, <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最优时间复杂度：O(nlogn)<br>最坏时间复杂度：O(n2)<br>稳定性：不稳定<br>从一开始快速排序平均需要花费O(n log n)时间的描述并不明显。但是不难观察到的是分区运算，数组的元素都会在每次循环中走访过一次，使用O(n)的时间。在使用结合（concatenation）的版本中，这项运算也是O(n)。</p><p>在最好的情况，每次我们运行一次分区，我们会把一个数列分为两个几近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要作log n次嵌套的调用。这个意思就是调用树的深度是O(log n)。但是在同一层次结构的两个程序调用中，不会处理到原来数列的相同部分；因此，程序调用的每一层次结构总共全部仅需要O(n)的时间（每个调用有某些共同的额外耗费，但是因为在每一层次结构仅仅只有O(n)个调用，这些被归纳在O(n)系数中）。结果是这个算法仅需使用O(n log n)时间。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(alist)</span></span><span class="symbol">:</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="comment"># 初始步长</span></span><br><span class="line">    gap = n / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span><span class="symbol">:</span></span><br><span class="line">        <span class="comment"># 按步长进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n)<span class="symbol">:</span></span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j&gt;=gap <span class="keyword">and</span> alist[j-gap] &gt; alist[j]<span class="symbol">:</span></span><br><span class="line">                alist[j-gap], alist[j] = alist[j], alist[j-gap]</span><br><span class="line">                j -= gap</span><br><span class="line">        <span class="comment"># 得到新的步长</span></span><br><span class="line">        gap = gap / <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>最优时间复杂度：根据步长序列的不同而不同</li><li>最坏时间复杂度：O(n2)</li><li>稳定性：不稳定</li></ul><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是采用分治法的一个非常典型的应用。归并排序的思想就是先递归分解数组，再合并数组。</p><p>将数组分解最小之后，然后合并两个有序数组，基本思路是比较两个数组的最前面的数，谁小就先取谁，取了后相应的指针就往后移一位。然后再比较，直至一个数组为空，最后把另一个数组的剩余部分复制过来即可。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def merge_sort(alist):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(alist) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="literal">return</span> alist</span><br><span class="line">    <span class="comment"># 二分分解</span></span><br><span class="line">    <span class="built_in">num</span> = <span class="built_in">len</span>(alist)/<span class="number">2</span></span><br><span class="line">    left = merge_sort(alist[:<span class="built_in">num</span>])</span><br><span class="line">    <span class="literal">right</span> = merge_sort(alist[<span class="built_in">num</span>:])</span><br><span class="line">    <span class="comment"># 合并</span></span><br><span class="line">    <span class="literal">return</span> <span class="built_in">merge</span>(left,<span class="literal">right</span>)</span><br><span class="line"></span><br><span class="line">def <span class="built_in">merge</span>(left, <span class="literal">right</span>):</span><br><span class="line">    <span class="string">''</span><span class="string">'合并操作，将两个有序数组left[]和right[]合并成一个大的有序数组'</span><span class="string">''</span></span><br><span class="line">    <span class="comment">#left与right的下标指针</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="built_in">result</span> = []</span><br><span class="line">    <span class="keyword">while</span> l&lt;<span class="built_in">len</span>(left) <span class="keyword">and</span> r&lt;<span class="built_in">len</span>(<span class="literal">right</span>):</span><br><span class="line">        <span class="keyword">if</span> left[l] &lt; <span class="literal">right</span>[r]:</span><br><span class="line">            <span class="built_in">result</span>.append(left[l])</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">result</span>.append(<span class="literal">right</span>[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">    <span class="built_in">result</span> += left[l:]</span><br><span class="line">    <span class="built_in">result</span> += <span class="literal">right</span>[r:]</span><br><span class="line">    <span class="literal">return</span> <span class="built_in">result</span></span><br></pre></td></tr></table></figure></p><h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最优时间复杂度：O(nlogn)</li><li>最坏时间复杂度：O(nlogn)</li><li>稳定性：稳定</li></ul><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好；其缺点是要求待查表为有序表<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def binary_search(alist, <span class="keyword">item</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(alist) == <span class="number">0</span>:</span><br><span class="line">        <span class="literal">return</span> False</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        midpoint = <span class="built_in">len</span>(alist)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> alist[midpoint]==<span class="keyword">item</span>:</span><br><span class="line">          <span class="literal">return</span> True</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">item</span>&lt;alist[midpoint]:</span><br><span class="line">            <span class="literal">return</span> binary_search(alist[:midpoint],<span class="keyword">item</span>)</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">            <span class="literal">return</span> binary_search(alist[midpoint+<span class="number">1</span>:],<span class="keyword">item</span>)</span><br></pre></td></tr></table></figure></p><h3 id="时间复杂度-6"><a href="#时间复杂度-6" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最优时间复杂度：O(1)</li><li>最坏时间复杂度：O(logn)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常见时间复杂度之间的关系&quot;&gt;&lt;a href=&quot;#常见时间复杂度之间的关系&quot; class=&quot;headerlink&quot; title=&quot;常见时间复杂度之间的关系&quot;&gt;&lt;/a&gt;常见时间复杂度之间的关系&lt;/h3&gt;&lt;p&gt;O(1) &amp;lt; O(logn) &amp;lt; O(n) &amp;lt; O(nlogn) &amp;lt; O(n2) &amp;lt; O(n3) &amp;lt; O(2n) &amp;lt; O(n!) &amp;lt; O(nn)&lt;/p&gt;
&lt;h3 id=&quot;排序算法的稳定性&quot;&gt;&lt;a href=&quot;#排序算法的稳定性&quot; class=&quot;headerlink&quot; title=&quot;排序算法的稳定性&quot;&gt;&lt;/a&gt;排序算法的稳定性&lt;/h3&gt;&lt;p&gt;稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。&lt;/p&gt;
&lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;h4 id=&quot;冒泡排序算法的运作如下：&quot;&gt;&lt;a href=&quot;#冒泡排序算法的运作如下：&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序算法的运作如下：&quot;&gt;&lt;/a&gt;冒泡排序算法的运作如下：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。&lt;/li&gt;
&lt;li&gt;对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。&lt;/li&gt;
&lt;li&gt;针对所有的元素重复以上的步骤，除了最后一个。&lt;/li&gt;
&lt;li&gt;持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bubble_sort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(alist)&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(len(alist)-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# j表示每次遍历需要比较的次数，是逐渐减小的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(j)&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; alist[i] &amp;gt; alist[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;symbol&quot;&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alist[i], alist[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = alist[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], alist[i]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）&lt;/li&gt;
&lt;li&gt;最坏时间复杂度：O(n2)&lt;/li&gt;
&lt;li&gt;稳定性：稳定
    
    </summary>
    
      <category term="-python" scheme="https://dword.top/categories/python/"/>
    
    
      <category term="-常见排序" scheme="https://dword.top/tags/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>响应码</title>
    <link href="https://dword.top/%E7%8A%B6%E6%80%81%E7%A0%81.html"/>
    <id>https://dword.top/状态码.html</id>
    <published>2017-10-10T16:00:00.000Z</published>
    <updated>2018-12-24T02:28:02.293Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1xx-信息"><a href="#1xx-信息" class="headerlink" title="1xx:信息"></a>1xx:信息</h4><h5 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h5><p>服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。<br>  </p><h5 id="101-Switching-Protocols"><a href="#101-Switching-Protocols" class="headerlink" title="101 Switching Protocols"></a>101 Switching Protocols</h5><p>服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。<br> </p><h4 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx:成功"></a>2xx:成功</h4><h5 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h5><p>请求成功（其后是对GET和POST请求的应答文档<br> ）  </p><h5 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h5><p>请求被创建完成，同时新的资源被创建。<br> </p><h5 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h5><p>供处理的请求已被接受，但是处理未完成。<br> </p><h5 id="203-Non-authoritative-Information"><a href="#203-Non-authoritative-Information" class="headerlink" title="203 Non-authoritative Information"></a>203 Non-authoritative Information</h5><p>文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。<br> <a id="more"></a></p><h5 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h5><p>没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。<br> </p><h5 id="205-Reset-Content"><a href="#205-Reset-Content" class="headerlink" title="205 Reset Content"></a>205 Reset Content</h5><p>没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。<br> </p><h5 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h5><p>客户发送了一个带有Range头的GET请求，服务器完成了它。<br> </p><h4 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx:重定向"></a>3xx:重定向</h4><h5 id="300-Multiple-Choices"><a href="#300-Multiple-Choices" class="headerlink" title="300 Multiple Choices"></a>300 Multiple Choices</h5><p>多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。<br> </p><h5 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h5><p>所请求的页面已经转移至新的url。<br> </p><h5 id="302-Moved-Temporarily"><a href="#302-Moved-Temporarily" class="headerlink" title="302 Moved Temporarily"></a>302 Moved Temporarily</h5><p>所请求的页面已经临时转移至新的url。<br> </p><h5 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h5><p>所请求的页面可在别的url下被找到。<br> </p><h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><p>未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。<br> </p><h5 id="305-Use-Proxy"><a href="#305-Use-Proxy" class="headerlink" title="305 Use Proxy"></a>305 Use Proxy</h5><p>客户请求的文档应该通过Location头所指明的代理服务器提取。<br> </p><h5 id="306-Unused"><a href="#306-Unused" class="headerlink" title="306 Unused"></a>306 Unused</h5><p>此代码被用于前一版本。目前已不再使用，但是代码依然被保留。<br> </p><h5 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h5><p>被请求的页面已经临时移至新的url。<br> </p><h4 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx:客户端错误"></a>4xx:客户端错误</h4><h5 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h5><p>服务器未能理解请求。<br> </p><h5 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h5><p>被请求的页面需要用户名和密码。<br> </p><h5 id="401-1"><a href="#401-1" class="headerlink" title="401.1"></a>401.1</h5><p>登录失败。<br> </p><h5 id="401-2"><a href="#401-2" class="headerlink" title="401.2"></a>401.2</h5><p>服务器配置导致登录失败。<br> </p><h5 id="401-3"><a href="#401-3" class="headerlink" title="401.3"></a>401.3</h5><p>由于 ACL 对资源的限制而未获得授权。<br> </p><h5 id="401-4"><a href="#401-4" class="headerlink" title="401.4"></a>401.4</h5><p>筛选器授权失败。<br> </p><h5 id="401-5"><a href="#401-5" class="headerlink" title="401.5"></a>401.5</h5><p>ISAPI/CGI 应用程序授权失败。<br> </p><h5 id="401-7"><a href="#401-7" class="headerlink" title="401.7"></a>401.7</h5><p>访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。<br> </p><h5 id="402-Payment-Required"><a href="#402-Payment-Required" class="headerlink" title="402 Payment Required"></a>402 Payment Required</h5><p>此代码尚无法使用。<br> </p><h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><p>对被请求页面的访问被禁止。<br> </p><h5 id="403-1"><a href="#403-1" class="headerlink" title="403.1"></a>403.1</h5><p>执行访问被禁止。<br> </p><h5 id="403-2"><a href="#403-2" class="headerlink" title="403.2"></a>403.2</h5><p>读访问被禁止。<br> </p><h5 id="403-3"><a href="#403-3" class="headerlink" title="403.3"></a>403.3</h5><p>写访问被禁止。<br> </p><h5 id="403-4"><a href="#403-4" class="headerlink" title="403.4"></a>403.4</h5><p>要求 SSL。<br> </p><h5 id="403-5"><a href="#403-5" class="headerlink" title="403.5"></a>403.5</h5><p>要求 SSL 128。<br> </p><h5 id="403-6"><a href="#403-6" class="headerlink" title="403.6"></a>403.6</h5><p>IP 地址被拒绝。<br> </p><h5 id="403-7"><a href="#403-7" class="headerlink" title="403.7"></a>403.7</h5><p>要求客户端证书。<br> </p><h5 id="403-8"><a href="#403-8" class="headerlink" title="403.8"></a>403.8</h5><p>站点访问被拒绝。<br> </p><h5 id="403-9"><a href="#403-9" class="headerlink" title="403.9"></a>403.9</h5><p>用户数过多。<br> </p><h5 id="403-10"><a href="#403-10" class="headerlink" title="403.10"></a>403.10</h5><p>配置无效。<br> </p><h5 id="403-11"><a href="#403-11" class="headerlink" title="403.11"></a>403.11</h5><p>密码更改。<br> </p><h5 id="403-12"><a href="#403-12" class="headerlink" title="403.12"></a>403.12</h5><p>拒绝访问映射表。<br> </p><h5 id="403-13"><a href="#403-13" class="headerlink" title="403.13"></a>403.13</h5><p>客户端证书被吊销。<br> </p><h5 id="403-14"><a href="#403-14" class="headerlink" title="403.14"></a>403.14</h5><p>拒绝目录列表。<br> </p><h5 id="403-15"><a href="#403-15" class="headerlink" title="403.15"></a>403.15</h5><p>超出客户端访问许可。<br> </p><h5 id="403-16"><a href="#403-16" class="headerlink" title="403.16"></a>403.16</h5><p>客户端证书不受信任或无效。<br> </p><h5 id="403-17"><a href="#403-17" class="headerlink" title="403.17"></a>403.17</h5><p>客户端证书已过期或尚未生效。<br> </p><h5 id="403-18"><a href="#403-18" class="headerlink" title="403.18"></a>403.18</h5><p>在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。<br> </p><h5 id="403-19"><a href="#403-19" class="headerlink" title="403.19"></a>403.19</h5><p>不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。<br> </p><h5 id="403-20"><a href="#403-20" class="headerlink" title="403.20"></a>403.20</h5><p>Passport 登录失败。这个错误代码为 IIS 6.0 所专用。<br> </p><h5 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h5><p>服务器无法找到被请求的页面。<br> </p><h5 id="404-0"><a href="#404-0" class="headerlink" title="404.0"></a>404.0</h5><p>没有找到文件或目录。<br> </p><h5 id="404-1"><a href="#404-1" class="headerlink" title="404.1"></a>404.1</h5><p>无法在所请求的端口上访问 Web 站点。<br> </p><h5 id="404-2"><a href="#404-2" class="headerlink" title="404.2"></a>404.2</h5><p>Web 服务扩展锁定策略阻止本请求。<br> </p><h5 id="404-3"><a href="#404-3" class="headerlink" title="404.3"></a>404.3</h5><p>MIME 映射策略阻止本请求。<br> </p><h5 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h5><p>请求中指定的方法不被允许。<br> </p><h5 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h5><p>服务器生成的响应无法被客户端所接受。<br> </p><h5 id="407-Proxy-Authentication-Required"><a href="#407-Proxy-Authentication-Required" class="headerlink" title="407 Proxy Authentication Required"></a>407 Proxy Authentication Required</h5><p>用户必须首先使用代理服务器进行验证，这样请求才会被处理。<br> </p><h5 id="408-Request-Timeout"><a href="#408-Request-Timeout" class="headerlink" title="408 Request Timeout"></a>408 Request Timeout</h5><p>请求超出了服务器的等待时间。<br> </p><h5 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 Conflict"></a>409 Conflict</h5><p>由于冲突，请求无法被完成。<br> </p><h5 id="410-Gone"><a href="#410-Gone" class="headerlink" title="410 Gone"></a>410 Gone</h5><p>被请求的页面不可用。<br> </p><h5 id="411-Length-Required"><a href="#411-Length-Required" class="headerlink" title="411 Length Required"></a>411 Length Required</h5><p>“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。<br> </p><h5 id="412-Precondition-Failed"><a href="#412-Precondition-Failed" class="headerlink" title="412 Precondition Failed"></a>412 Precondition Failed</h5><p>请求中的前提条件被服务器评估为失败。<br> </p><h5 id="413-Request-Entity-Too-Large"><a href="#413-Request-Entity-Too-Large" class="headerlink" title="413 Request Entity Too Large"></a>413 Request Entity Too Large</h5><p>由于所请求的实体的太大，服务器不会接受请求。<br> </p><h5 id="414-Request-url-Too-Long"><a href="#414-Request-url-Too-Long" class="headerlink" title="414 Request-url Too Long"></a>414 Request-url Too Long</h5><p>由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。<br> </p><h5 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h5><p>由于媒介类型不被支持，服务器不会接受请求。<br> </p><h5 id="416-Requested-Range-Not-Satisfiable"><a href="#416-Requested-Range-Not-Satisfiable" class="headerlink" title="416 Requested Range Not Satisfiable"></a>416 Requested Range Not Satisfiable</h5><p>服务器不能满足客户在请求中指定的Range头。<br> </p><h5 id="417-Expectation-Failed"><a href="#417-Expectation-Failed" class="headerlink" title="417 Expectation Failed"></a>417 Expectation Failed</h5><p>执行失败。<br> </p><h5 id="423"><a href="#423" class="headerlink" title="423"></a>423</h5><p>锁定的错误。<br> </p><h4 id="5xx-服务器错误"><a href="#5xx-服务器错误" class="headerlink" title="5xx:服务器错误"></a>5xx:服务器错误</h4><h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><p>请求未完成。服务器遇到不可预知的情况。<br> </p><h5 id="500-12"><a href="#500-12" class="headerlink" title="500.12"></a>500.12</h5><p>应用程序正忙于在 Web 服务器上重新启动。<br> </p><h5 id="500-13"><a href="#500-13" class="headerlink" title="500.13"></a>500.13</h5><p>Web 服务器太忙。<br> </p><h5 id="500-15"><a href="#500-15" class="headerlink" title="500.15"></a>500.15</h5><p>不允许直接请求 Global.asa。<br> </p><h5 id="500-16"><a href="#500-16" class="headerlink" title="500.16"></a>500.16</h5><p>UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。<br> </p><h5 id="500-18"><a href="#500-18" class="headerlink" title="500.18"></a>500.18</h5><p>URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。<br> </p><h5 id="500-100"><a href="#500-100" class="headerlink" title="500.100"></a>500.100</h5><p>内部 ASP 错误。<br> </p><h5 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h5><p>请求未完成。服务器不支持所请求的功能。<br> </p><h5 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h5><p>请求未完成。服务器从上游服务器收到一个无效的响应。<br> </p><h5 id="502-1"><a href="#502-1" class="headerlink" title="502.1"></a>502.1</h5><p>CGI 应用程序超时。　·<br> </p><h5 id="502-2"><a href="#502-2" class="headerlink" title="502.2"></a>502.2</h5><p>CGI 应用程序出错。<br> </p><h5 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h5><p>请求未完成。服务器临时过载或当机。<br> </p><h5 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h5><p>网关超时。<br> </p><h5 id="505-HTTP-Version-Not-Supported"><a href="#505-HTTP-Version-Not-Supported" class="headerlink" title="505 HTTP Version Not Supported"></a>505 HTTP Version Not Supported<br></h5>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1xx-信息&quot;&gt;&lt;a href=&quot;#1xx-信息&quot; class=&quot;headerlink&quot; title=&quot;1xx:信息&quot;&gt;&lt;/a&gt;1xx:信息&lt;/h4&gt;&lt;h5 id=&quot;100-Continue&quot;&gt;&lt;a href=&quot;#100-Continue&quot; class=&quot;headerlink&quot; title=&quot;100 Continue&quot;&gt;&lt;/a&gt;100 Continue&lt;/h5&gt;&lt;p&gt;服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。&lt;br&gt;  &lt;/p&gt;
&lt;h5 id=&quot;101-Switching-Protocols&quot;&gt;&lt;a href=&quot;#101-Switching-Protocols&quot; class=&quot;headerlink&quot; title=&quot;101 Switching Protocols&quot;&gt;&lt;/a&gt;101 Switching Protocols&lt;/h5&gt;&lt;p&gt;服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。&lt;br&gt; &lt;/p&gt;
&lt;h4 id=&quot;2xx-成功&quot;&gt;&lt;a href=&quot;#2xx-成功&quot; class=&quot;headerlink&quot; title=&quot;2xx:成功&quot;&gt;&lt;/a&gt;2xx:成功&lt;/h4&gt;&lt;h5 id=&quot;200-OK&quot;&gt;&lt;a href=&quot;#200-OK&quot; class=&quot;headerlink&quot; title=&quot;200 OK&quot;&gt;&lt;/a&gt;200 OK&lt;/h5&gt;&lt;p&gt;请求成功（其后是对GET和POST请求的应答文档&lt;br&gt; ）  &lt;/p&gt;
&lt;h5 id=&quot;201-Created&quot;&gt;&lt;a href=&quot;#201-Created&quot; class=&quot;headerlink&quot; title=&quot;201 Created&quot;&gt;&lt;/a&gt;201 Created&lt;/h5&gt;&lt;p&gt;请求被创建完成，同时新的资源被创建。&lt;br&gt; &lt;/p&gt;
&lt;h5 id=&quot;202-Accepted&quot;&gt;&lt;a href=&quot;#202-Accepted&quot; class=&quot;headerlink&quot; title=&quot;202 Accepted&quot;&gt;&lt;/a&gt;202 Accepted&lt;/h5&gt;&lt;p&gt;供处理的请求已被接受，但是处理未完成。&lt;br&gt; &lt;/p&gt;
&lt;h5 id=&quot;203-Non-authoritative-Information&quot;&gt;&lt;a href=&quot;#203-Non-authoritative-Information&quot; class=&quot;headerlink&quot; title=&quot;203 Non-authoritative Information&quot;&gt;&lt;/a&gt;203 Non-authoritative Information&lt;/h5&gt;&lt;p&gt;文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。&lt;br&gt;
    
    </summary>
    
      <category term="-http" scheme="https://dword.top/categories/http/"/>
    
    
      <category term="-response.status" scheme="https://dword.top/tags/response-status/"/>
    
  </entry>
  
  <entry>
    <title>结构化非结构化数据处理</title>
    <link href="https://dword.top/%E5%BE%97%E5%88%B0%E6%95%B0%E6%8D%AE.html"/>
    <id>https://dword.top/得到数据.html</id>
    <published>2017-10-10T16:00:00.000Z</published>
    <updated>2018-12-24T02:28:35.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="非结构化数据"><a href="#非结构化数据" class="headerlink" title="非结构化数据"></a>非结构化数据</h3><p>非结构化数据是数据结构不规则或不完整，没有预定义的数据模型，不方便用数据库二维逻辑表来表现的数据。包括所有格式的办公文档、文本、图片、XML, HTML、各类报表、图像和音频/视频信息等等。</p><h3 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h3><p>结构化数据可以使用关系型数据库来表示和存储，如MySQL、Oracle、SQL Server等，表现二维形式的数据。可以通过固有键值获取相应信息。一般特点是：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。结构化的数据的存储和排列是很有规律的，这对查询和修改等操作很有帮助。但是，显然，它的扩展性不好</p><h3 id="选择方法"><a href="#选择方法" class="headerlink" title="选择方法"></a>选择方法</h3><p>可选择的方式有很多，这里介绍正则，跟xpath,其他的实际运用中哪个更好用用哪个就行了</p><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><p>在 Python 中，使用内置的 re 模块 <br><br>compile() 函数将正则表达式的字符串形式编译为一个 Pattern 对象<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'正则规则'</span>)</span><br><span class="line">Pattern  对象的一些常用方法</span><br><span class="line">match(string[, pos[, endpos]]):    从起始位置开始查找，一次匹配</span><br><span class="line">search(string[, pos[, endpos]])：  从任何位置开始查找，一次匹配</span><br><span class="line"><span class="comment"># &lt;&lt;&lt;&lt;&lt;&lt;成功返回Match 对象，失败返回None&gt;&gt;&gt;&gt;&gt;&gt;</span></span><br><span class="line">findall(string[, pos[, endpos]])：   全部匹配，返回列表/空列表</span><br><span class="line">finditer(string[, pos[, endpos]])：  全部匹配，返回(Match对象)迭代器</span><br><span class="line">split(string[, maxsplit])：          能够匹配的子串进行分割，返回列表</span><br><span class="line">sub(repl, string[, count])：替换</span><br><span class="line"><span class="comment"># 引用分组可以用(\6 \1', string))</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h5 id="Match-对象方法"><a href="#Match-对象方法" class="headerlink" title="Match 对象方法"></a>Match 对象方法</h5><ul><li><p>group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)；</p></li><li><p>start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0；</p></li><li><p>([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0；</p></li><li><p>span([group]) 方法返回 (start(group), end(group))。</p></li></ul><h4 id="贪婪非贪婪模式"><a href="#贪婪非贪婪模式" class="headerlink" title="贪婪非贪婪模式"></a>贪婪非贪婪模式</h4><p>字符串abbbef<br>贪婪模式：在整个表达式匹配成功的前提下，尽可能多的匹配 ( <em> )<br><br>ab</em> ，匹配结果： abbb<br>非贪婪模式：在整个表达式匹配成功的前提下结束匹配，尽可能少的匹配 ( ? )<br>ab*？ ，匹配结果： a</p><h3 id="xpath"><a href="#xpath" class="headerlink" title="xpath"></a>xpath</h3><h3 id="lxml"><a href="#lxml" class="headerlink" title="lxml"></a>lxml</h3><p>lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> lxml</span><br></pre></td></tr></table></figure></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(url) <span class="comment">#发送请求</span></span><br><span class="line">html = response.content.decode() <span class="comment">#获取html字符串</span></span><br><span class="line">res = etree.parse(html)</span><br><span class="line">result = res.xpath('//li/a[@href=<span class="string">"li.html"</span>]')</span><br></pre></td></tr></table></figure><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><h5 id="json-loads-jsonstr"><a href="#json-loads-jsonstr" class="headerlink" title="json.loads(jsonstr)"></a>json.loads(jsonstr)</h5><p>把Json格式字符串解码转换成Python对象</p><h5 id="json-dumps-python"><a href="#json-dumps-python" class="headerlink" title="json.dumps(python)"></a>json.dumps(python)</h5><p>把一个Python对象编码转换成Json字符串<br>序列化时默认使用的ascii编码 添加参数 ensure_ascii=False 禁用ascii编码,按utf-8编码</p><h5 id="json-dump-python-open-‘src-json-w’"><a href="#json-dump-python-open-‘src-json-w’" class="headerlink" title="json.dump(python, open(‘src.json,w’)"></a>json.dump(python, open(‘src.json,w’)</h5><p>将Python内置类型序列化为json对象后写入文件</p><h5 id="json-load-open-‘src-json’"><a href="#json-load-open-‘src-json’" class="headerlink" title="json.load(open(‘src.json’)"></a>json.load(open(‘src.json’)</h5><p>读取文件中json形式的字符串元素 转化成python类型</p><h3 id="xpath规则"><a href="#xpath规则" class="headerlink" title="xpath规则"></a>xpath规则</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">表达式描述</span><br><span class="line"><span class="symbol">nodename</span>选取此节点的所有子节点。</span><br><span class="line">/从根节点选取。</span><br><span class="line">//从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</span><br><span class="line">.选取当前节点。</span><br><span class="line"><span class="symbol">..</span>选取当前节点的父节点。</span><br><span class="line"><span class="comment">@选取属性。</span></span><br><span class="line"></span><br><span class="line">路径表达式                            结果</span><br><span class="line">/<span class="keyword">bookstore/book[1]</span>            选取属于 <span class="keyword">bookstore </span>子元素的第一个 <span class="keyword">book </span>元素。</span><br><span class="line">/<span class="keyword">bookstore/book[last()]</span>        选取属于 <span class="keyword">bookstore </span>子元素的最后一个 <span class="keyword">book </span>元素。</span><br><span class="line">/<span class="keyword">bookstore/book[last()-1]</span>    选取属于 <span class="keyword">bookstore </span>子元素的倒数第二个 <span class="keyword">book </span>元素。</span><br><span class="line">/<span class="keyword">bookstore/book[position()&lt;3]</span>选取最前面的两个属于 <span class="keyword">bookstore </span>元素的子元素的 <span class="keyword">book </span>元素。</span><br><span class="line">//title[<span class="comment">@lang]选取所有拥有名为 lang 的属性的 title 元素。</span></span><br><span class="line">//title[<span class="comment">@lang=’eng’]选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</span></span><br><span class="line">/<span class="keyword">bookstore/book[price&gt;35.00]</span>选取 <span class="keyword">bookstore </span>元素的所有 <span class="keyword">book </span>元素，且其中的 price 元素的值须大于 <span class="number">35</span>.<span class="number">00</span>。</span><br><span class="line">/<span class="keyword">bookstore/book[price&gt;35.00]/title</span>选取 <span class="keyword">bookstore </span>元素中的 <span class="keyword">book </span>元素的所有 title 元素，且其中的 price 元素的值须大于 <span class="number">35</span>.<span class="number">00</span>。</span><br></pre></td></tr></table></figure><h4 id="正则规则"><a href="#正则规则" class="headerlink" title="正则规则"></a>正则规则</h4><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">字符描述</span><br><span class="line"><span class="symbol">\</span>对下一个字符转义。例如，。“<span class="symbol">\n</span>”匹配一个换行符。串行“<span class="symbol">\\</span>”匹配“<span class="symbol">\”</span>而“<span class="symbol">\(</span>”则匹配“(”。</span><br><span class="line">^匹配的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“<span class="symbol">\n</span>”或“<span class="symbol">\r</span>”之后的位置。</span><br><span class="line">$匹配结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“<span class="symbol">\n</span>”或“<span class="symbol">\r</span>”之前的位置。</span><br><span class="line">*匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于&#123;0,&#125;。</span><br><span class="line">+匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于&#123;1,&#125;。</span><br><span class="line">?匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于&#123;0,1&#125;。</span><br><span class="line">&#123;n&#125;n是一个非负整数。匹配确定的n次。例如，“o&#123;2&#125;”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</span><br><span class="line">&#123;n,&#125;n是一个非负整数。至少匹配n次。例如，“o&#123;2,&#125;”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o&#123;1,&#125;”等价于“o+”。“o&#123;0,&#125;”则等价于“o*”。</span><br><span class="line">&#123;n,m&#125;m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o&#123;1,3&#125;”将匹配“fooooood”中的前三个o。“o&#123;0,1&#125;”等价于“o?”。请注意在逗号和两个数之间不能有空格。</span><br><span class="line">?当该字符紧跟在任何一个其他限制符（*,+,?，&#123;n&#125;，&#123;n,&#125;，&#123;n,m&#125;）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</span><br><span class="line">.匹配除“<span class="symbol">\n</span>”之外的任何单个字符。要匹配包括“<span class="symbol">\n</span>”在内的任何字符，请使用像“(.|<span class="symbol">\n</span>)”的模式。</span><br><span class="line">(pattern)匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“<span class="symbol">\(</span>”或“<span class="symbol">\)</span>”。</span><br><span class="line">(?:pattern)匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。</span><br><span class="line">(?=pattern)正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</span><br><span class="line">(?!pattern)正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</span><br><span class="line">(?&lt;=pattern)反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</span><br><span class="line">(?&lt;!pattern)反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。</span><br><span class="line">x|y匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。</span><br><span class="line">[xyz]字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</span><br><span class="line">[^xyz]负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。</span><br><span class="line">[a-z]字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</span><br><span class="line">[^a-z]负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</span><br><span class="line"><span class="symbol">\b</span>匹配一个单词边界，也就是指单词和空格间的位置。例如，“er<span class="symbol">\b</span>”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</span><br><span class="line"><span class="symbol">\B</span>匹配非单词边界。“er<span class="symbol">\B</span>”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</span><br><span class="line"><span class="symbol">\c</span>x匹配由x指明的控制字符。例如，<span class="symbol">\c</span>M匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</span><br><span class="line"><span class="symbol">\d</span>匹配一个数字字符。等价于[0-9]。</span><br><span class="line"><span class="symbol">\D</span>匹配一个非数字字符。等价于[^0-9]。</span><br><span class="line"><span class="symbol">\f</span>匹配一个换页符。等价于<span class="symbol">\x</span>0c和<span class="symbol">\c</span>L。</span><br><span class="line"><span class="symbol">\n</span>匹配一个换行符。等价于<span class="symbol">\x</span>0a和<span class="symbol">\c</span>J。</span><br><span class="line"><span class="symbol">\r</span>匹配一个回车符。等价于<span class="symbol">\x</span>0d和<span class="symbol">\c</span>M。</span><br><span class="line"><span class="symbol">\s</span>匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ <span class="symbol">\f</span><span class="symbol">\n</span><span class="symbol">\r</span><span class="symbol">\t</span><span class="symbol">\v</span>]。</span><br><span class="line"><span class="symbol">\S</span>匹配任何非空白字符。等价于[^ <span class="symbol">\f</span><span class="symbol">\n</span><span class="symbol">\r</span><span class="symbol">\t</span><span class="symbol">\v</span>]。</span><br><span class="line"><span class="symbol">\t</span>匹配一个制表符。等价于<span class="symbol">\x</span>09和<span class="symbol">\c</span>I。</span><br><span class="line"><span class="symbol">\v</span>匹配一个垂直制表符。等价于<span class="symbol">\x</span>0b和<span class="symbol">\c</span>K。</span><br><span class="line"><span class="symbol">\w</span>匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。</span><br><span class="line"><span class="symbol">\W</span>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</span><br><span class="line"><span class="symbol">\x</span>n匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“<span class="symbol">\x</span>41”匹配“A”。“<span class="symbol">\x</span>041”则等价于“<span class="symbol">\x</span>04&amp;1”。正则表达式中可以使用ASCII编码。.</span><br><span class="line"><span class="symbol">\n</span>um匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)<span class="symbol">\1</span>”匹配两个连续的相同字符。</span><br><span class="line"><span class="symbol">\n</span>标识一个八进制转义值或一个向后引用。如果<span class="symbol">\n</span>之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。</span><br><span class="line"><span class="symbol">\n</span>m标识一个八进制转义值或一个向后引用。如果<span class="symbol">\n</span>m之前至少有nm个获得子表达式，则nm为向后引用。如果<span class="symbol">\n</span>m之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则<span class="symbol">\n</span>m将匹配八进制转义值nm。</span><br><span class="line"><span class="symbol">\n</span>ml如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。</span><br><span class="line"><span class="symbol">\u</span>n匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，<span class="symbol">\u</span>00A9匹配版权符号（©）。</span><br><span class="line">常用正则表达式</span><br><span class="line">用户名/^[a-z0-9_-]&#123;3,16&#125;$/</span><br><span class="line">密码/^[a-z0-9_-]&#123;6,18&#125;$/</span><br><span class="line">十六进制值/^#?([a-f0-9]&#123;6&#125;|[a-f0-9]&#123;3&#125;)$/</span><br><span class="line">电子邮箱/^([a-z0-9_<span class="symbol">\.</span>-]+)@([<span class="symbol">\d</span>a-z<span class="symbol">\.</span>-]+)<span class="symbol">\.</span>([a-z<span class="symbol">\.</span>]&#123;2,6&#125;)$/</span><br><span class="line">/^[a-z<span class="symbol">\d</span>]+(<span class="symbol">\.</span>[a-z<span class="symbol">\d</span>]+)*@([<span class="symbol">\d</span>a-z](-[<span class="symbol">\d</span>a-z])?)+(<span class="symbol">\.</span>&#123;1,2&#125;[a-z]+)+$/</span><br><span class="line">URL/^(https?:<span class="symbol">\/</span><span class="symbol">\/</span>)?([<span class="symbol">\d</span>a-z<span class="symbol">\.</span>-]+)<span class="symbol">\.</span>([a-z<span class="symbol">\.</span>]&#123;2,6&#125;)([<span class="symbol">\/</span><span class="symbol">\w</span> <span class="symbol">\.</span>-]*)*<span class="symbol">\/</span>?$/</span><br><span class="line">IP 地址/((2[0-4]<span class="symbol">\d</span>|25[0-5]|[01]?<span class="symbol">\d</span><span class="symbol">\d</span>?)<span class="symbol">\.</span>)&#123;3&#125;(2[0-4]<span class="symbol">\d</span>|25[0-5]|[01]?<span class="symbol">\d</span><span class="symbol">\d</span>?)/</span><br><span class="line">/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)<span class="symbol">\.</span>)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</span><br><span class="line">HTML 标签/^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;<span class="symbol">\/</span><span class="symbol">\1</span>&gt;|<span class="symbol">\s</span>+<span class="symbol">\/</span>&gt;)$/</span><br><span class="line">删除代码<span class="symbol">\\</span>注释(?&lt;!http:|<span class="symbol">\S</span>)//.*$</span><br><span class="line">Unicode编码中的汉字范围/^[<span class="symbol">\u</span>2E80-<span class="symbol">\u</span>9FFF]+$/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;非结构化数据&quot;&gt;&lt;a href=&quot;#非结构化数据&quot; class=&quot;headerlink&quot; title=&quot;非结构化数据&quot;&gt;&lt;/a&gt;非结构化数据&lt;/h3&gt;&lt;p&gt;非结构化数据是数据结构不规则或不完整，没有预定义的数据模型，不方便用数据库二维逻辑表来表现的数据。包括所有格式的办公文档、文本、图片、XML, HTML、各类报表、图像和音频/视频信息等等。&lt;/p&gt;
&lt;h3 id=&quot;结构化数据&quot;&gt;&lt;a href=&quot;#结构化数据&quot; class=&quot;headerlink&quot; title=&quot;结构化数据&quot;&gt;&lt;/a&gt;结构化数据&lt;/h3&gt;&lt;p&gt;结构化数据可以使用关系型数据库来表示和存储，如MySQL、Oracle、SQL Server等，表现二维形式的数据。可以通过固有键值获取相应信息。一般特点是：数据以行为单位，一行数据表示一个实体的信息，每一行数据的属性是相同的。结构化的数据的存储和排列是很有规律的，这对查询和修改等操作很有帮助。但是，显然，它的扩展性不好&lt;/p&gt;
&lt;h3 id=&quot;选择方法&quot;&gt;&lt;a href=&quot;#选择方法&quot; class=&quot;headerlink&quot; title=&quot;选择方法&quot;&gt;&lt;/a&gt;选择方法&lt;/h3&gt;&lt;p&gt;可选择的方式有很多，这里介绍正则，跟xpath,其他的实际运用中哪个更好用用哪个就行了&lt;/p&gt;
&lt;h3 id=&quot;正则&quot;&gt;&lt;a href=&quot;#正则&quot; class=&quot;headerlink&quot; title=&quot;正则&quot;&gt;&lt;/a&gt;正则&lt;/h3&gt;&lt;p&gt;在 Python 中，使用内置的 re 模块 &lt;br&gt;&lt;br&gt;compile() 函数将正则表达式的字符串形式编译为一个 Pattern 对象&lt;br&gt;&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pattern = re.compile(&lt;span class=&quot;string&quot;&gt;r&#39;正则规则&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Pattern  对象的一些常用方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;match(string[, pos[, endpos]]):    从起始位置开始查找，一次匹配&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;search(string[, pos[, endpos]])：  从任何位置开始查找，一次匹配&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;成功返回Match 对象，失败返回None&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;findall(string[, pos[, endpos]])：   全部匹配，返回列表/空列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;finditer(string[, pos[, endpos]])：  全部匹配，返回(Match对象)迭代器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;split(string[, maxsplit])：          能够匹配的子串进行分割，返回列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sub(repl, string[, count])：替换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 引用分组可以用(\6 \1&#39;, string))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="-python" scheme="https://dword.top/categories/python/"/>
    
    
      <category term="xpath" scheme="https://dword.top/tags/xpath/"/>
    
      <category term="re" scheme="https://dword.top/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>k-近邻实现《机器学习实战》</title>
    <link href="https://dword.top/k-%E8%BF%91%E9%82%BB.html"/>
    <id>https://dword.top/k-近邻.html</id>
    <published>2017-09-28T16:00:00.000Z</published>
    <updated>2018-07-30T08:47:25.913Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;knn算法的实现原理是将测试数据集与样本数据集中数据对应的特征进行比较，提取k个特征最相似数据的分类标签。<br><strong>1.先做一个简单的数据</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#简单数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dataset</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    定义一个简单数据集</span></span><br><span class="line"><span class="string">    :return: train 数据集，labels 对应的标签</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    train = array([[<span class="number">1</span>, <span class="number">0.1</span>], [<span class="number">0</span>, <span class="number">0.1</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">    labels = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>]</span><br><span class="line">    <span class="keyword">return</span> train, labels</span><br></pre></td></tr></table></figure></p><p><strong>2.实现knn算法</strong><br>计算两个向量点xA和xB之间的距离需要使用到欧式距离公式  </p><p>$d(x,y)=\sqrt{(x_1-y_1)^{2}+(x_2-y_2)^{2}+(x_n-y_n)^{2}}=\sqrt{\sum_{i=1}^{n}(x_i-y_i)^{2}}$</p><p>例如，点(0,0)与(1,2)之间的距离计算为： </p><p>$\sqrt{(1-0)^{2}+(2-0)^{2}}$</p><p>如果数据集存在4个特征值， 则点(1,0,0,1)与(7,6,9,4)之间的距离计算为:</p><p>$\sqrt{(7-1)^{2}+(6-0)^{2}+(9-0)^{2}+(4-1)^{2}}$</p><a id="more"></a><p>计算完距离以后对数据进行从小到的排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Knn</span><span class="params">(inputdate, train, lablel , k)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    首先是要做欧式距离运算的，所以首先</span></span><br><span class="line"><span class="string">    1.是把输入的指矩阵进行复制可与测试的模型进行运算</span></span><br><span class="line"><span class="string">    2.排序以后取前k个相近的值进行分类</span></span><br><span class="line"><span class="string">    3.返回那个分类</span></span><br><span class="line"><span class="string">    :param inputdate: 测试数据</span></span><br><span class="line"><span class="string">    :param train: 样本数据</span></span><br><span class="line"><span class="string">    :param lablel: 样本数据标签</span></span><br><span class="line"><span class="string">    :param k: k值</span></span><br><span class="line"><span class="string">    :return: 最近标签</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment">#对输入数据做处理，跟样本数据一样的维度大小</span></span><br><span class="line">    inputdata = tile(inputdate,(train.shape[<span class="number">0</span>],<span class="number">1</span>))</span><br><span class="line">    <span class="comment">#对数据集做欧式距离运算</span></span><br><span class="line">    vla = (inputdata - train)**<span class="number">2</span></span><br><span class="line">    vlaue = (vla.sum(axis=<span class="number">1</span>))**<span class="number">0.05</span></span><br><span class="line">    <span class="comment">#返回从小到大的索引</span></span><br><span class="line">    sortval = vlaue.argsort()</span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line">    <span class="comment">#取前k个值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        <span class="comment">#保存成对应的键值对</span></span><br><span class="line">        dict[vlaue[sortval[i]]]=lablel[sortval[i]]</span><br><span class="line">    sortcalsscount = sorted(dict.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">0</span>])</span><br><span class="line">    print(<span class="string">"排序以后的%"</span>,sortcalsscount)</span><br><span class="line">    <span class="keyword">return</span> sortcalsscount[<span class="number">0</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>如果想用现有的数据集，对数据集进行特征抽取，下一篇有做介绍</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;knn算法的实现原理是将测试数据集与样本数据集中数据对应的特征进行比较，提取k个特征最相似数据的分类标签。&lt;br&gt;&lt;strong&gt;1.先做一个简单的数据&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#简单数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dataset&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    定义一个简单数据集&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    :return: train 数据集，labels 对应的标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    &#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    train = array([[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    labels = [&lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;B&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;B&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; train, labels&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.实现knn算法&lt;/strong&gt;&lt;br&gt;计算两个向量点xA和xB之间的距离需要使用到欧式距离公式  &lt;/p&gt;
&lt;p&gt;$d(x,y)=\sqrt{(x_1-y_1)^{2}+(x_2-y_2)^{2}+(x_n-y_n)^{2}}=\sqrt{\sum_{i=1}^{n}(x_i-y_i)^{2}}$&lt;/p&gt;
&lt;p&gt;例如，点(0,0)与(1,2)之间的距离计算为： &lt;/p&gt;
&lt;p&gt;$\sqrt{(1-0)^{2}+(2-0)^{2}}$&lt;/p&gt;
&lt;p&gt;如果数据集存在4个特征值， 则点(1,0,0,1)与(7,6,9,4)之间的距离计算为:&lt;/p&gt;
&lt;p&gt;$\sqrt{(7-1)^{2}+(6-0)^{2}+(9-0)^{2}+(4-1)^{2}}$&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://dword.top/categories/python/"/>
    
    
      <category term="python" scheme="https://dword.top/tags/python/"/>
    
      <category term="numpy" scheme="https://dword.top/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>算法对比</title>
    <link href="https://dword.top/%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94.html"/>
    <id>https://dword.top/算法对比.html</id>
    <published>2017-09-27T16:00:00.000Z</published>
    <updated>2018-06-25T17:25:29.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><h3 id="监督学习-输入征值-目标值。输出可以是一个连接的值-称为回归-或是有限离散值-分类"><a href="#监督学习-输入征值-目标值。输出可以是一个连接的值-称为回归-或是有限离散值-分类" class="headerlink" title="监督学习(输入征值+目标值。输出可以是一个连接的值(称为回归)或是有限离散值(分类)"></a><font color="green" size="3">监督学习(输入征值+目标值。输出可以是一个连接的值(称为回归)或是有限离散值(分类)</font><br></h3><h4 id="分类-lt-模型评估用查准率，查全率，精度，错误率-gt"><a href="#分类-lt-模型评估用查准率，查全率，精度，错误率-gt" class="headerlink" title="分类&lt;模型评估用查准率，查全率，精度，错误率&gt;"></a><font color="orange" size="3">分类&lt;模型评估用查准率，查全率，精度，错误率&gt;</font><br></h4><p>k-近邻(kneighbors)、贝叶斯(naive_bayes)分类、决策树与随机森林(randomForestClassifier)、逻辑回归(LogisticRegression)、神经网络<br></p><h4 id="回归-lt-模型评估用局方误差-gt"><a href="#回归-lt-模型评估用局方误差-gt" class="headerlink" title="回归&lt;模型评估用局方误差&gt;"></a><font color="orange" size="3">回归&lt;模型评估用局方误差&gt;</font><br></h4><p>线性回归(LinearRegression)、岭回归(Ridge)<br></p><h4 id="标注-隐马尔可夫模型"><a href="#标注-隐马尔可夫模型" class="headerlink" title="标注 隐马尔可夫模型"></a><font color="orange" size="3">标注 隐马尔可夫模型</font><br></h4><h3 id="无监督学习-输入特征值推测新的结果"><a href="#无监督学习-输入特征值推测新的结果" class="headerlink" title="无监督学习(输入特征值推测新的结果)"></a><font color="green" size="3">无监督学习(输入特征值推测新的结果)</font><br></h3><p>&nbsp;聚类 k-means</p><a id="more"></a><hr><h2 id="算法优缺点对比"><a href="#算法优缺点对比" class="headerlink" title="算法优缺点对比"></a>算法优缺点对比</h2><h3 id="k-近邻-小数据场景，几千-几万样本"><a href="#k-近邻-小数据场景，几千-几万样本" class="headerlink" title="k-近邻(小数据场景，几千~几万样本)"></a>k-近邻(小数据场景，几千~几万样本)</h3><p>采用欧式距离公式计算亮点之间的距离</p><ul><li>优点<br>&nbsp;&nbsp;简单，易于理解，易于实现，无需估计参数，无需训练<br></li><li>缺点<br>&nbsp;&nbsp;1.  测试样本计算量打，内存开销大<br><br>&nbsp;&nbsp;2. 必须指定k值，k值选择不当则分类精度不能保证</li></ul><hr><h3 id="朴素贝叶斯分类-MultinomiaLNB"><a href="#朴素贝叶斯分类-MultinomiaLNB" class="headerlink" title="朴素贝叶斯分类(MultinomiaLNB)"></a>朴素贝叶斯分类(MultinomiaLNB)</h3><ul><li>优点：<br><br>&nbsp;&nbsp;1.有稳定的分类效率<br>&nbsp;&nbsp;2.对确实数据不太敏感，算法也比较简单，常用于文本分类。<br>&nbsp;&nbsp;3.分类准确度高，速度快。  </li><li>缺点：<br>&nbsp;&nbsp;  需要知道先验概率P（F1，F2…|C).因此在某些时候会犹豫假设的先验模型的原因导致预测效果不佳。<br></li></ul><hr><h3 id="kmeans"><a href="#kmeans" class="headerlink" title="kmeans"></a>kmeans</h3><ul><li><p>特点分析：采用迭代式算法，直观易懂并且非常实用。  </p></li><li><p>缺点：容易收敛到局部最优解(多次聚类)<br><br>&nbsp;&nbsp;需要预先设定簇的数量(k-means++解决)</p></li></ul><hr><h3 id="随机森林-大数据集"><a href="#随机森林-大数据集" class="headerlink" title="随机森林(大数据集)"></a>随机森林(大数据集)</h3><p>&nbsp;&nbsp;1. 在当前所有算法中，具有极好的准确率。<br><br>&nbsp;&nbsp;2. 能够有效的运行在大数据集上。<br><br>&nbsp;&nbsp;3. 能够处理高维特征，不需要降维。<br><br>&nbsp;&nbsp;4. 能够评估各个特征在分类问题上的重要性。<br><br>&nbsp;&nbsp;5. 对于缺省值问题也能够活得很好的结果。<br></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法分类&quot;&gt;&lt;a href=&quot;#算法分类&quot; class=&quot;headerlink&quot; title=&quot;算法分类&quot;&gt;&lt;/a&gt;算法分类&lt;/h2&gt;&lt;h3 id=&quot;监督学习-输入征值-目标值。输出可以是一个连接的值-称为回归-或是有限离散值-分类&quot;&gt;&lt;a href=&quot;#监督学习-输入征值-目标值。输出可以是一个连接的值-称为回归-或是有限离散值-分类&quot; class=&quot;headerlink&quot; title=&quot;监督学习(输入征值+目标值。输出可以是一个连接的值(称为回归)或是有限离散值(分类)&quot;&gt;&lt;/a&gt;&lt;font color=&quot;green&quot; size=&quot;3&quot;&gt;监督学习(输入征值+目标值。输出可以是一个连接的值(称为回归)或是有限离散值(分类)&lt;/font&gt;&lt;br&gt;&lt;/h3&gt;&lt;h4 id=&quot;分类-lt-模型评估用查准率，查全率，精度，错误率-gt&quot;&gt;&lt;a href=&quot;#分类-lt-模型评估用查准率，查全率，精度，错误率-gt&quot; class=&quot;headerlink&quot; title=&quot;分类&amp;lt;模型评估用查准率，查全率，精度，错误率&amp;gt;&quot;&gt;&lt;/a&gt;&lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;分类&amp;lt;模型评估用查准率，查全率，精度，错误率&amp;gt;&lt;/font&gt;&lt;br&gt;&lt;/h4&gt;&lt;p&gt;k-近邻(kneighbors)、贝叶斯(naive_bayes)分类、决策树与随机森林(randomForestClassifier)、逻辑回归(LogisticRegression)、神经网络&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;回归-lt-模型评估用局方误差-gt&quot;&gt;&lt;a href=&quot;#回归-lt-模型评估用局方误差-gt&quot; class=&quot;headerlink&quot; title=&quot;回归&amp;lt;模型评估用局方误差&amp;gt;&quot;&gt;&lt;/a&gt;&lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;回归&amp;lt;模型评估用局方误差&amp;gt;&lt;/font&gt;&lt;br&gt;&lt;/h4&gt;&lt;p&gt;线性回归(LinearRegression)、岭回归(Ridge)&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;标注-隐马尔可夫模型&quot;&gt;&lt;a href=&quot;#标注-隐马尔可夫模型&quot; class=&quot;headerlink&quot; title=&quot;标注 隐马尔可夫模型&quot;&gt;&lt;/a&gt;&lt;font color=&quot;orange&quot; size=&quot;3&quot;&gt;标注 隐马尔可夫模型&lt;/font&gt;&lt;br&gt;&lt;/h4&gt;&lt;h3 id=&quot;无监督学习-输入特征值推测新的结果&quot;&gt;&lt;a href=&quot;#无监督学习-输入特征值推测新的结果&quot; class=&quot;headerlink&quot; title=&quot;无监督学习(输入特征值推测新的结果)&quot;&gt;&lt;/a&gt;&lt;font color=&quot;green&quot; size=&quot;3&quot;&gt;无监督学习(输入特征值推测新的结果)&lt;/font&gt;&lt;br&gt;&lt;/h3&gt;&lt;p&gt;&amp;nbsp;聚类 k-means&lt;/p&gt;
    
    </summary>
    
      <category term="随记" scheme="https://dword.top/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
      <category term="机器学习算法" scheme="https://dword.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>在Hexo中渲染MathJax数学公式</title>
    <link href="https://dword.top/hexo%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93.html"/>
    <id>https://dword.top/hexo数学公式渲染.html</id>
    <published>2017-08-10T16:00:00.000Z</published>
    <updated>2018-06-25T17:23:50.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转-https-www-jianshu-com-p-7ab21c7f0674"><a href="#转-https-www-jianshu-com-p-7ab21c7f0674" class="headerlink" title="转: https://www.jianshu.com/p/7ab21c7f0674"></a>转: <a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="nofollow">https://www.jianshu.com/p/7ab21c7f0674</a></h2><p>在用markdown写技术文档时，免不了会碰到数学公式。常用的Markdown编辑器都会集成<a href="https://link.jianshu.com?t=https%3A%2F%2Fwww.mathjax.org%2F" target="_blank" rel="nofollow">Mathjax</a>，用来渲染文档中的类Latex格式书写的数学公式。基于Hexo搭建的个人博客，默认情况下渲染数学公式却会出现各种各样的问题。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如在markdown语法中，下划线’_’代表斜体，会被渲染引擎处理为&lt;em&gt;标签。<br>因为类Latex格式书写的数学公式下划线 ‘_’ 表示下标，有特殊的含义，如果被强制转换为<code>&lt;em&gt;</code>标签，那么MathJax引擎在渲染数学公式的时候就会出错。例如，$x_i$在开始被渲染的时候，处理为$x<code>&lt;em&gt;</code>i<code>&lt;/em&gt;</code>$，这样MathJax引擎就认为该公式有语法错误，因为不会渲染。<br>类似的语义冲突的符号还包括’*’, ‘{‘, ‘}’, ‘\’等。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方案有很多，可以网上搜下，为了节省大家的时间，这里只提供亲身测试过的最靠谱的方法。<br>更换Hexo的markdown渲染引擎，<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fsun11%2Fhexo-renderer-kramed" target="_blank" rel="nofollow">hexo-renderer-kramed</a>引擎是在默认的渲染引擎<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fhexojs%2Fhexo-renderer-marked" target="_blank" rel="nofollow">hexo-renderer-marked</a>的基础上修改了一些bug，两者比较接近，也比较轻量级。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">uninstall</span> hexo-renderer-marked <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-kramed <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>执行上面的命令即可，先卸载原来的渲染引擎，再安装新的。<br><a id="more"></a><br>然后，跟换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为<a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fsun11%2Fhexo-renderer-kramed" target="_blank" rel="nofollow">hexo-renderer-kramed</a>引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，把第11行的escape变量的值做相应的修改：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  escape: /^\\([<span class="string">\\`*&#123;&#125;\[\</span>](<span class="link"></span>)#$+\-.!_&amp;gt;])/,</span><br><span class="line">escape: /^\\([<span class="string">`*\[\</span>](<span class="link"></span>)#$+\-.!_&amp;gt;])/</span><br></pre></td></tr></table></figure><p>这一步是在原基础上取消了对\,{,}的转义(escape)。<br><br>同时把第20行的em变量也要做相应的修改。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  em: /^<span class="symbol">\b</span>_((?:__|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)_<span class="symbol">\b</span>|^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/,</span><br><span class="line">em: /^<span class="symbol">\*</span>((?:<span class="symbol">\*</span><span class="symbol">\*</span>|[<span class="symbol">\s</span><span class="symbol">\S</span>])+?)<span class="symbol">\*</span>(?!<span class="symbol">\*</span>)/</span><br></pre></td></tr></table></figure><p>重新启动hexo（先clean再generate）,问题完美解决。哦，如果不幸还没解决的话，看看是不是还需要在使用的主题中配置mathjax开关。</p><h2 id="在主题中开启mathjax开关"><a href="#在主题中开启mathjax开关" class="headerlink" title="在主题中开启mathjax开关"></a>在主题中开启mathjax开关</h2><p>如何使用了主题了，别忘了在主题（Theme）中开启mathjax开关，下面以next主题为例，介绍下如何打开mathjax开关。<br>进入到主题目录，找到_config.yml配置问题，把mathjax默认的false修改为true，具体如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>别着急，这样还不够，还需要在文章的Front-matter里打开mathjax开关，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">index.html</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2016</span><span class="bullet">-12</span><span class="bullet">-28</span> <span class="number">21</span><span class="string">:01:30</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-</span></span><br></pre></td></tr></table></figure><p>不要嫌麻烦，之所以要在文章头里设置开关，是因为考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了。<br>最后，试过好多网上写的各种配置，折腾了一天，这个是一次就成功的，在这里真心感谢作者！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;转-https-www-jianshu-com-p-7ab21c7f0674&quot;&gt;&lt;a href=&quot;#转-https-www-jianshu-com-p-7ab21c7f0674&quot; class=&quot;headerlink&quot; title=&quot;转: https://www.jianshu.com/p/7ab21c7f0674&quot;&gt;&lt;/a&gt;转: &lt;a href=&quot;https://www.jianshu.com/p/7ab21c7f0674&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;https://www.jianshu.com/p/7ab21c7f0674&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在用markdown写技术文档时，免不了会碰到数学公式。常用的Markdown编辑器都会集成&lt;a href=&quot;https://link.jianshu.com?t=https%3A%2F%2Fwww.mathjax.org%2F&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;Mathjax&lt;/a&gt;，用来渲染文档中的类Latex格式书写的数学公式。基于Hexo搭建的个人博客，默认情况下渲染数学公式却会出现各种各样的问题。&lt;/p&gt;
&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;Hexo默认使用”hexo-renderer-marked”引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如在markdown语法中，下划线’_’代表斜体，会被渲染引擎处理为&amp;lt;em&amp;gt;标签。&lt;br&gt;因为类Latex格式书写的数学公式下划线 ‘_’ 表示下标，有特殊的含义，如果被强制转换为&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;标签，那么MathJax引擎在渲染数学公式的时候就会出错。例如，$x_i$在开始被渲染的时候，处理为$x&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;i&lt;code&gt;&amp;lt;/em&amp;gt;&lt;/code&gt;$，这样MathJax引擎就认为该公式有语法错误，因为不会渲染。&lt;br&gt;类似的语义冲突的符号还包括’*’, ‘{‘, ‘}’, ‘\’等。&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h2&gt;&lt;p&gt;解决方案有很多，可以网上搜下，为了节省大家的时间，这里只提供亲身测试过的最靠谱的方法。&lt;br&gt;更换Hexo的markdown渲染引擎，&lt;a href=&quot;https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fsun11%2Fhexo-renderer-kramed&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;hexo-renderer-kramed&lt;/a&gt;引擎是在默认的渲染引擎&lt;a href=&quot;https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Fhexojs%2Fhexo-renderer-marked&quot; target=&quot;_blank&quot; rel=&quot;nofollow&quot;&gt;hexo-renderer-marked&lt;/a&gt;的基础上修改了一些bug，两者比较接近，也比较轻量级。&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm &lt;span class=&quot;keyword&quot;&gt;uninstall&lt;/span&gt; hexo-renderer-marked &lt;span class=&quot;comment&quot;&gt;--save&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm &lt;span class=&quot;keyword&quot;&gt;install&lt;/span&gt; hexo-renderer-kramed &lt;span class=&quot;comment&quot;&gt;--save&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行上面的命令即可，先卸载原来的渲染引擎，再安装新的。&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://dword.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://dword.top/tags/hexo/"/>
    
      <category term="MathJax" scheme="https://dword.top/tags/MathJax/"/>
    
      <category term="Latex" scheme="https://dword.top/tags/Latex/"/>
    
  </entry>
  
</feed>
